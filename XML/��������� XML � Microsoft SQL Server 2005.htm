<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<title>Поддержка XML в Microsoft SQL Server 2005
</title>
<link rel="STYLESHEET" type="text/css" href="%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0%20XML%20%D0%B2%20Microsoft%20SQL%20Server%202005_files/main.css">
<meta name="description" content="XML Support in Microsoft SQL Server 2005"> 
<meta name="keywords" content="SQL, DBA, Microsoft, server,  database">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>
<body leftmargin="3" topmargin="3" bgcolor="#FFFFFF" marginheight="3" marginwidth="3">
<noindex>
<table bgcolor="#000000" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td>

<table border="0" cellpadding="0" cellspacing="1" width="100%">
<tbody><tr bgcolor="#6699CC"><td><table bgcolor="#6699CC" border="0" cellpadding="0" cellspacing="0" width="100%">
<tbody><tr><td colspan="3"><img src="%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0%20XML%20%D0%B2%20Microsoft%20SQL%20Server%202005_files/blank.gif" alt="" height="3" width="1"></td></tr>
<tr><td valign="TOP">&nbsp;<font color="lightyellow" face="Verdana,Arial" size="5">SQL.RU<br><font size="-5">&nbsp;client/server technologies</font></font></td>
<td height="60" align="RIGHT" bgcolor="#6699CC" width="468"></td>
<td width="2"><img src="%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0%20XML%20%D0%B2%20Microsoft%20SQL%20Server%202005_files/blank.gif" alt="" height="1" width="2"></td></tr>                                                      	
<tr height="4"><td colspan="3"><img src="%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0%20XML%20%D0%B2%20Microsoft%20SQL%20Server%202005_files/blank.gif" alt="" height="5" width="1"></td></tr></tbody></table>

</td></tr>

<tr height="15"><td bgcolor="#006699"><font color="WHITE" face="Verdana,Arial" size="1"><b><a class="menu" href="http://www.sql.ru/">&nbsp;<font color="white">Главная</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/docs">&nbsp;<font color="white">Документация</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/articles">&nbsp;<font color="yellow">Статьи</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/books">&nbsp;<font color="white">Книги</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/forum/actualforum.aspx">&nbsp;<font color="white">Форум</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/blogs">&nbsp;<font color="white">Блоги</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/poll">&nbsp;<font color="white">Опросы</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/forum/actualtopics.aspx?bid=11">&nbsp;<font color="white">Гостевая</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/subscribe">&nbsp;<font color="white">Рассылка</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/job">&nbsp;<font color="white">Работа</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/search">&nbsp;<font color="white">Поиск</font>&nbsp;</a>|<a class="menu" href="http://www.sql.ru/faq">&nbsp;<font color="white">FAQ</font>&nbsp;</a>|</b></font></td></tr>
<tr><td bgcolor="#F5F5F5">


<table bgcolor="#666666" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td><table border="0" cellpadding="2" cellspacing="1" width="100%"><tbody><tr bgcolor="#006699"><td>
<table border="0" cellpadding="2" cellspacing="1" width="100%"><tbody><tr><td>
<font color="white"><p><a name="0"></a><b>Поддержка XML в Microsoft SQL Server 2005</b></p></font></td>
<td align="right" valign="bottom"><font size="-1"><p><a class="menu" href="http://www.sql.ru/articles/Publications.shtml">ПУБЛИКАЦИИ</a>&nbsp;&nbsp;</p></font></td>
</tr></tbody></table></td></tr></tbody></table></td></tr></tbody></table>
<table border="0" cellpadding="2" cellspacing="10">
<tbody><tr>
<td>
<div align="justify">
<p>
По материалам статьи <a href="http://msdn.microsoft.com/SQL/sqlreldata/XML/default.aspx?pull=/library/en-us/dnsql90/html/sql2k5xml.asp">
XML Support in Microsoft SQL Server 2005</a><br>
Перевод <a href="http://www.sql.ru/forum/actualtopics.aspx?bid=55">Виталия Степаненко</a></p>
<p>
</p><p>
В этой статье рассматривается добавленная в SQL Server 2005 поддержка XML. 
В статье также показано, как эта поддержка интегрируется с программной поддержкой
со стороны клиента в .NET Framework V2.0 и в родном коде, как OLEDB и SQLXML.</p>
<p>
</p><p><font color="#330066" size="+1">
<a name="0"></a><b>СОДЕРЖАНИЕ</b></font></p>
<ul><p>
<a href="#01"><b>Введение</b></a><br>
<a href="#02">Почему для данных XML используются реляционные базы данных?</a><br>
<a href="#03">Поддержка XML в SQL Server 2000</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#04">Поддержка XML на стороне сервера</a><br>
&nbsp;&nbsp;&nbsp;<a href="#05">Поддержка XML на стороне клиента</a><br>
&nbsp;&nbsp;&nbsp;<a href="#06">Ограничения в поддержке XML</a><br></font>
<a href="#07">Обзор поддержки XML в SQL Server 2005</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#08">Тип данных XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#09">Запрос данных XML и модификация данных</a><br>
&nbsp;&nbsp;&nbsp;<a href="#10">Индексирование XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#11">Обработка схем XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#12">Интеграция реляционных данных и данных XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#13">Улучшения в FOR XML и OpenXML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#14">Клиентский доступ к типу данных XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#15">Поддержка XML при помощи XQuery на стороне клиента</a><br></font>
<a href="#16"><b>Мотивация для хранения XML</b></a><br>
<a href="#17">Управление свойствами пользователем</a><br>
<a href="#18">Обмен данными</a><br>
<a href="#19">Управление документами</a><br>
<a href="#20"><b>Обработка XML на стороне сервера в SQL Server 2005</b></a><br>
<a href="#21">Тип данных XML</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#22">Нетипизированный XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#23">Типизированный XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#24">Ограничения столбцов типа XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#25">Кодировка текста</a><br>
&nbsp;&nbsp;&nbsp;<a href="#26">Хранение данных XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#27">Представление данных при хранении</a><br>
&nbsp;&nbsp;&nbsp;<a href="#28">Взгляд на моделирование данных</a><br></font>
<a href="#29">Выполнение запросов и модификация данных XML</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#30">Методы типа XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#31">Язык XQuery</a><br>
&nbsp;&nbsp;&nbsp;<a href="#32">Компиляция и выполнение запроса</a><br>
&nbsp;&nbsp;&nbsp;<a href="#33">Изменение данных XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#34">Проверка типа и статические ошибки</a><br>
&nbsp;&nbsp;&nbsp;<a href="#35">Междоменные запросы</a><br>
&nbsp;&nbsp;&nbsp;<a href="#36">Генерация набора строк из данных XML</a><br></font>
<a href="#37">Индексирование данных XML</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#38">Первичный индекс XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#39">Вторичные индексы XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#40">Индексирование содержимого</a><br>
&nbsp;&nbsp;&nbsp;<a href="#41">Выполнение запроса с использованием индексов XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#42">Каталожные представления для индексов XML<br></a></font><a href="#42">
</a><a href="#43">Обработка схем XML</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#44">Коллекция схем XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#45">Изменение коллекции схем XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#46">Каталожные представления для коллекций схем XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#47">Контроль доступа к коллекциям схем XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#48">Видимость каталожных представлений</a><br></font>
<a href="#49">Улучшения в FOR XML</a><br>
<a href="#50">Руководство по производительности</a><br>
<a href="#51">Поддержка XML в SQL Server CLR</a><br>
<a href="#52"><b>Обработка XML на стороне клиента в SQL Server 2005</b></a><br>
<a href="#53">Поддержка XML на стороне клиента</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#54">Поддержка ADO.NET XML в .NET Framework V2.0</a><br>
&nbsp;&nbsp;&nbsp;<a href="#55">Встроенный клиентский доступ к SQL</a><br></font>
<a href="#56">Создание представления XML реляционных таблиц</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#57">Конвертация SQLXML между XML и реляционными схемами</a><br>
&nbsp;&nbsp;&nbsp;<a href="#58">Конвертация отношений для создания иерархий в представлениях XML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#59">Использование столбца overflow для хранения нераспределенных данных</a><br>
&nbsp;&nbsp;&nbsp;<a href="#60">Дополнительная информация</a></font><br>
<a href="#61">Выполнение запросов к представлениям XML с использованием XPath</a><br>
<a href="#62">Обновление через представления XML с использованием апдейтаграмм</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#63">Структура апдейтаграммы</a><br>
&nbsp;&nbsp;&nbsp;<a href="#64">Операции вставки</a><br>
&nbsp;&nbsp;&nbsp;<a href="#65">Операции удаления</a><br>
&nbsp;&nbsp;&nbsp;<a href="#66">Операции обновления</a><br>
&nbsp;&nbsp;&nbsp;<a href="#67">Дополнительная информация</a></font><br>
<a href="#68">Bulk загрузка данных XML через представления XML</a><br>
<a href="#69">Методы доступа к данным SQLXML</a><br><font size="-1">
&nbsp;&nbsp;&nbsp;<a href="#70">Управляемые классы SQLXML</a><br>
&nbsp;&nbsp;&nbsp;<a href="#71">Сетевые службы SQLXML</a></font><br>
<a href="#72">XQuery в .NET Framework 2.0</a><br>
<a href="#73"><b>Заключение</b></a></p></ul>

<p><font color="#330066" size="+2">
<a name="01"></a><b>Введение</b></font></p>
<p>
Расширенный язык разметки (eXtensible Markup Language, XML) широко 
распространен
как платформо-независимый формат представления данных. Он полезен для 
обмена информацией между различными слабосвязанными системами,
как в приложениях business-to-business (B2B), так и в других ситуациях.
Обмен данными был главным двигателем развития технологий XML.</p>
<p>
XML все больше используется в приложениях уровня предприятия для моделирования 
частично структурированных и неструктурированных данных. Одно из таких приложений - это управление документами.
Документы, такие, как e-mail, являются изначально частично структурированными. 
Если документы хранятся внутри сервера базы данных в виде XML, то достаточно мощные
приложения могут быть разработаны для получения документов, основанные на содержимом 
документов, объединении документов, и запросах на получение части содержимого документа,
как, например, поиск главы документа с заголовком, содержащим слово "background". 
Такие сценарии становятся все более возможными с ростом количества приложений,
которые генерируют и потребляют XML.
Например, система Microsoft Office 2003 позволяет пользователям создавать документы Word, Excel, Visio и Infopath в виде XML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="02"></a><b>Почему для данных XML используются реляционные базы данных?</b></font></p>
<p></p><ul><p>
</p><li><p>Хранение данных XML в реляционной базе данных имеет свои преимущества при
управлении данными и обработке запросов. SQL Server обеспечивает большие возможности для выполнения запросов к реляционным
данным и изменения этих данных, которые были расширены для выполнения запросов 
по данным XML и их изменения. Это позволяет увеличить отдачу от инвестиций, как, например, в областях оптимизации
затрат ресурсов и хранилищ данных. Например, методы индексирования в реляционной базе данных хорошо известны, и они
были расширены для индексирования данных XML так, чтобы запросы могли быть оптимизированы
с учетом затрат ресурсов.</p></li>
<li><p>Данные XML могут взаимодействовать с существующими реляционными 
данными и приложениями 
SQL так, чтобы XML мог быть добавлен в систему при возникновении новых 
потребностей без 
серьезного изменения существующих приложений. Сервер базы данных также 
обеспечивает административную функциональность для управления
данными XML (например, резервное копирование, восстановление и 
репликация).</p></li>
<li><p>Эти возможности породили потребность в поддержке встроенного XML в SQL Server 2005 
для отражения увеличивающегося использования XML. Разработка приложений уровня предприятия сильно выиграет от поддержки XML
в SQL Server 2005.</p></li><p></p></ul><p></p>
<p>
Следующие главы дают обзор поддержки XML в SQL Server 2000 и 2005, описывают некоторые 
сценарии использования XML и углубляются в детали использования XML на стороне сервера и клиента.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="03"></a><b>Поддержка XML в SQL Server 2000</b></font></p>
<p>
Эта глава предоставляет краткий обзор поддержки XML в SQL Server 2000 и в
 последующих сетевых релизах платформы программирования SQLXML на 
клиентской стороне,
что обеспечивает широкую поддержку конвертации реляционных данных в XML,
 и наоборот.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="04"></a><b>Поддержка XML на стороне сервера</b></p>
<p>
На сервере данные XML могут быть сгенерированы из таблиц и результатов 
запросов, используя выражение FOR XML в команде SELECT.
Это идеально подходит для обмена данными и для приложений Web-сервисов. 
Обратной операцией для FOR XML является функция генератора реляционного 
набора строк
OpenXML; она заносит значения из данных XML в столбцы набора строк, 
используя выражения XPath 1.0.
OpenXML используется приложениями, которые заносят входные данные XML в 
таблицы или выполняют запросы, используя T-SQL.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="05"></a><b>Поддержка XML на стороне клиента</b></p>
<p>
Поддержка программирования на стороне клиента для SQL Server 2000 
относится к SQLXML. 
Центральное место этой технологии - представление XML, которое является 
двусторонней конвертацией схемы XML в реляционные таблицы.
SQL Server 2000 поддерживает только конвертацию схем XDR, хотя поддержка
 XSD была добавлена в более поздние web-релизы.
Представление XML позволяет выполнять запросы, используя подмножество 
XPath 1.0, где конвертация используется для перевода выражений пути в 
запросы SQL на таблицах,
и где результаты запроса вставляются в результат XML.</p>
<p>
SQLXML также позволяет создавать шаблоны XML, которые позволяют создавать документ XML с динамическими секциями.
В документ XML вы можете встраивать запросы FOR XML и/или выражения XPath 1.0 при помощи запросов конвертации.
Когда выполняется шаблон XML, блок запроса заменяется результатом этого запроса.
Т.е. Вы можете создавать документы XML со статическим содержанием и с динамическим содержанием, управляемым данными.</p>
<p>
В SQL Server 2000 есть два пути доступа к функциональности SQLXML:</p>
<p></p><ul><p>
</p><li><p>SQLXMLOLEDB Provider - провайдер SQLXMLOLEDB, это провайдер OLE DB, который
обеспечивает функциональность Microsoft SQLXML через ADO.</p></li>
<li><p>HTTP Access - функциональность SQLXML в SQL Server 2000 может также быть достигнута 
через HTTP, используя фильтр SQLXML ISAPI. Используя инструмент конфигурации, вы можете настроить веб-сайт на прием входящих
запросов на выполнение шаблонов XML и команд FOR XML и XPath 1.0 с помощью представлений XML через HTTP.</p></li><p></p></ul><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="06"></a><b>Ограничения в поддержке XML</b></p>
<p>
Серверная и клиентская платформы программирования обеспечивают широкую 
поддержку для генерации и потребления данных XML, основанных на 
конвертации между табличными 
данными и данными XML. Это позволяет хорошо управлять структурированными
 данными XML.
В SQLXML язык запросов является подмножеством XPath 1.0 и имеет 
некоторые ограничения. Например, не поддерживается descendant-or-self 
axis (//).
Следовательно, существуют ограничения при разработке определенных 
решений. Например, может не сохраниться порядок документа XML, что так 
критично для таких
приложений, как приложения управления документами. Более того, не 
поддерживаются рекурсивные схемы XML.
Несмотря на эти ограничения, функциональность клиентского SQLXML и 
серверного XML широко используется при разработке приложений.
SQL Server 2005 устраняет многие из этих ограничений, расширяет обмен 
между реляционными данными и данными XML и обеспечивает поддержку 
встроенного XML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="07"></a><b>Обзор поддержки XML в SQL Server 2005</b></font></p>
<p>
Эта глава предоставляет обзор поддержки XML, добавленной в SQL Server 
2005, которая дополняется поддержкой XML в .NET Framework V2.0 и 
клиентским доступом
к встроенному XML через OLE DB.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="08"></a><b>Тип данных XML</b></p>
<p>
Модель данных XML имеет такие характеристики, которые затрудняют, если 
вообще не делают невозможным процесс ее конвертации в реляционную модель
 данных.
Данные XML имеют иерархическую структуру, которая может быть 
рекурсивной; реляционные базы данных обеспечивают слабую поддержку для 
иерархических данных
(в виде внешних ключей). Порядок документа является одним из основных 
свойств XML и должен быть сохранен
в результате запроса. Это контрастирует с реляционными данными, которые 
неупорядочены, и их порядок
указывается с помощью дополнительных столбцов. Получение результата 
выполнения запроса достаточно затратно для реальных схем XML,
которые распределяют данные XML по большому количеству таблиц.</p>
<p>
В SQL Server 2005 появился встроенный тип данных - XML. Пользователь 
может создавать таблицу с одним или более столбцом типа XML помимо
столбцов с реляционными данными; также разрешены переменные и параметры 
типа XML. Значения XML хранятся во внутреннем формате как большие 
бинарные объекты (BLOB)
для лучшей поддержки характеристик модели XML, таких, как порядок 
документа и рекурсивные структуры.</p>
<p>
SQL Server 2005 обеспечивает набор схем XML в качестве средства по 
управлению схемами W3C XML как метаданными.
Тип данных XML может быть сопоставлен с набором схемы XML, чтобы 
наложить ограничения на экземпляры XML.
Когда данные типа XML сопоставляются с набором схем XML, они называются 
типизированными
данными XML; иначе они называются нетипизированными данными XML. И 
типизированные, и нетипизированные данные XML в одной структуре, модель 
данных
XML защищена, и обработка запроса использует семантику XML. Для этого в 
значительной степени используется имеющаяся реляционная инфраструктура.
Она обеспечивает взаимодействие между реляционными данными и данными 
XML, давая возможность для более широкого использования XML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="09"></a><b>Запрос данных XML и модификация данных</b></p>
<p>
Экземпляры XML могут быть получены с помощью команды SELECT языка T-SQL.
Пять встроенных методов на типе данных XML обеспечивают выполнение запросов и изменение экземпляров XML.</p>
<p>
Методы типа данных XML поддерживают XQuery, который является стандартом 
языка W3C и включает язык навигации XPath 2.0. 
Язык также доступен для изменения данных XML, например, для добавления 
или удаления поддеревьев и обновления скалярных значений.
Вместе с большим набором функций, встроенный XQuery и языки изменения 
данных обеспечивают богатую поддержку управления данными XML.</p>
<p>
Система типов XQuery соответствует типам схем XML у W3C. Большинство 
типов SQL совместимы с системой типов XQuery (например, десятичный тип).
Несколько типов (например, xs:duration) хранятся во внутреннем формате и
 они соответственно интерпретируются, чтобы быть совместимыми с системой
 типов XQuery.</p>
<p>
На фазе компиляции происходит проверка правильности статического типа выражений XQuery и
команд модификации и используются схемы XML для ссылки на типы в случае типизированных данных XML.
Ошибки статического типа возникают, если выражение не срабатывает во время работы из-за нарушения типа.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="10"></a><b>Индексирование XML</b></p>
<p>
При выполнении запроса каждый экземпляр XML обрабатывается во время 
работы; это может являться достаточно затратным, если значение XML имеет
 больший размер или
когда запрос возращает большое количество строк из таблицы. Для 
ускорения запросов создан механизм индексирования столбцов XML.</p>
<p>
Сбалансированные деревья интенсивно используются для индексирования 
реляционных данных. 
Первичный индекс XML по столбцам XML создает индекс со сбалансированным 
деревом
по всем тэгам, значениям и путям экземпляров XML в столбце. Это 
обеспечивает эффективную оценку запросов данных XML и сборку результата 
XML из
сбалансированного дерева, сохраняя порядок документа и его структуру.</p>
<p>
Вторичные индексы XML могут быть созданы по столбцу XML для ускорения различных классов 
типичных запросов: индекс PATH для основанных на пути запросов, индекс PROPERTY 
для сценариев свойств и индекс VALUE для основанных на значениях запросов.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="11"></a><b>Обработка схем XML</b></p>
<p>
Столбцы, переменные и параметры XML могут быть типизированы в соответствии 
с набором схем XML, которые могут быть связаны (например, используя &lt;xs:import&gt;) или не связаны друг с другом.
Каждый типизированный экземпляр XML устанавливает пространство имен из набора схем XML, относящихся к нему.
Движок базы данных проверяет экземпляр в соответствии со схемой XML во время изменения данных.</p>
<p>
Информация схемы XML используется при хранении и оптимизации запросов. 
Типизированные экземпляры XML содержат типизированные значения во 
внутреннем,
двоичном представлении, как и в индексах XML. Это обеспечивает 
эффективную обработку типизированных данных XML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="12"></a><b>Интеграция реляционных данных и данных XML</b></p>
<p>
Пользователи могут хранить и реляционные данные, и данные XML в одной и той же базе данных.
Т.е. движок базы данных знает, как работать с моделью данных XML в добавление к работе с моделью реляционных данных.
Реляционные данные и приложения SQL продолжают работать правильно при их обновлении до SQL Server 2005.
Данные XML, находящиеся в файлах и в столбцах text или image, могут быть перемещены в столбцы типа XML на сервере.  
Столбец XML может быть проиндексирован, запрошен и изменен с использованием методов типа данных XML.</p>
<p>
База данных улучшает существующую реляционную инфраструктуру и 
компоненты движка, такие, как движок хранения и обработчик запросов для 
обработки XML.
Например, индексы XML создают сбалансированные деревья, и можно видеть 
планы выполнения запросов.
Встроенная в реляционную структуру, такая функциональность управления 
данными,
как резервное копирование/восстановление и репликация, доступна и для 
данных XML.
Новые возможности управления данными, такие, как зеркалирование базы 
данных и снапшотный уровень изоляции, также работают с типом данных XML.</p>
<p>
Структурированные данные должны храниться в таблицах и реляционных 
столбцах. Тип данных XML - это подходящий выбор для частично 
структурированных данных и
данных с разметкой XML, когда приложение должно выполнять запросы по 
этим данным и их изменение.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="13"></a><b>Улучшения в FOR XML и OpenXML</b></p>
<p>
Существующая функциональность FOR XML была улучшена несколькими путями. 
Теперь можно работать с экземплярами данных XML и с другими новыми 
типами SQL,
например, с [n]varchar(max).</p>
<p>
Новая директива TYPE генерирует экземпляр типа данных XML, который может
 быть присвоен столбцу, переменной или параметру XML, или запрошен с 
использованием
методов типа данных XML. Это позволяет вызывать команды SELECT ... FOR 
XML TYPE одну из другой.</p>
<p>
Режим PATH позволяет пользователям определять путь в дереве XML, где должно находиться 
значение столбца, что вместе с вышеупомянутой вложенностью команд является более удобным, чем FOR XML EXPLICIT.</p>
<p>
Директива XSINIL, использующаяся вместе с ELEMENTS, конвертирует NULL в 
элемент с атрибутом xsi:nil="true".
Также, новая директива ROOT позволяет определить корневой узел во всех 
режимах FOR XML. Новая директива XMLSCHEMA генерирует внутреннюю схему 
XSD.</p>
<p>
Функциональные улучшения OpenXML состоят из использования типа данных XML в
sp_preparedocument и генерирования столбцов с типом XML и другими новыми типами SQL в результирующем наборе данных.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="14"></a><b>Клиентский доступ к типу данных XML</b></p>
<p>
Клиенты могут получать доступ к данным XML на сервере несколькими 
путями. Встроенный клиентский доступ к SQL, использующий ODBC и OLE DB, 
передает тип данных
XML как строку Unicode. OLE DB также обеспечивает доступ 
ISequentialStream к данным XML для передачи данных Unicode.</p>
<p>
Управляемый доступ с помощью ADO.NET в .NET Framework V2.0 передает 
данные XML как новый класс SqlXml.
Он поддерживает метод CreateReader(), который возвращает экземпляр 
XmlReader для чтения возвращенного XML.
Также DataSet может загружать экземпляры типа XML в столбцы на среднем 
уровне, которые могут быть отредактированы, как XML документ, и 
сохранены в SQL Server.
Оба этих метода позволяют запросам SQL быть выполненными на сервере для 
получения столбцов XML для дальнейшей работы с ними на среднем уровне.</p>
<p>
SOAP, который имеет прямой доступ к HTTP в SQL Server 2005, может быть 
использован для выполнения запросов, получения и изменения данных XML.</p>
<p>
И встроенные, и управляемые клиентские технологии обеспечивают новые 
интерфейсы для получения набора схем XML, которые определяют тип столбца
 XML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="15"></a><b>Поддержка XML при помощи XQuery на стороне клиента</b></p>
<p>
В дополнение к использованию ADO.NET для получения таблиц в реляционный 
DataSet, Вы можете напрямую загружать реляционные данные в документ XML 
на среднем уровне,
используя класс XQueryCommand. Этот класс обеспечивает обработку XQuery 
на среднем уровне с возможностью встраивания
команд T-SQL как части языка XQuery. В этом случае вы можете запрашивать
 как локальные файлы XML, так и получать данные
из SQL Server напрямую из таблицы или через хранимую процедуру базы 
данных, и загружать их в документ XML на среднем уровне.
Это значительно упрощает запросы в SQL Server, выдает результат запроса в
 специфическом формате XML, и передает его бизнес-партнеру без 
необходимости
загрузки данных в DataSet для выполнения изменений над данными.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+2">
<a name="16"></a><b>Мотивация для хранения XML</b></font></p>
<p>
Данные в виде XML становятся все более распространенными. Они могут представлять 
данные пользователя с описывающими их схемами XML или без них. И данные XML, и схемы 
XML должны использоваться вместе. Схемы XML для реальных приложений часто сложны, 
и конвертация этих схем XML в таблицы и столбцы -сложная задача. Осуществление 
такой конвертации в то время, когда изменяются схемы XML или добавляются новые, 
становится проблематичным. Довольно часто данные XML хранятся в файловой системе 
или в текстовом столбце на сервере базы данных. Текстовые столбцы имеют такие 
преимущества управления данными, как репликация и резервное копирование/восстановление, 
но не поддерживают запросы, основанные на структуре данных XML. С встроенной поддержкой 
XML разработка приложений, использующих XML, становится быстрее.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="17"></a><b>Управление свойствами пользователем</b></font></p>
<p>
Некоторые приложения, такие, как приложения с пользовательским интерфейсом, позволяют 
пользователям выбирать из фиксированного набора свойств. Другие позволяют пользователям 
определять собственные, необходимые им свойства. Такими пользовательскими свойствами 
можно управлять, если они хранятся в формате XML. Приложения могут поддерживать 
не только скалярные свойства:</p>
<p></p><ul><p>
</p><li><p>могут поддерживаться свойства объектов с множеством значений, такие, как множество 
номеров телефонов;</p></li>
<li><p>также могут поддерживаться сложные свойства, например, свойство автора документа 
может являться контактной информацией автора;</p></li>
<li><p>объектные свойства могут храниться в столбце типа XML и индексироваться для 
эффективной обработки запроса.</p></li><p></p></ul><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="18"></a><b>Обмен данными</b></font></p>
<p>
XML позволяет осуществлять платформо-независимый обмен данными между приложениями. 
Такие данные могут быть смоделированы как сообщения с разметкой XML. Вместо постоянного 
создания и удаления сообщений XML, разумнее хранить сообщения в формате XML. Это 
хорошо сочетается с требованиями обмена данными. Приходящее сообщение XML содержит 
текущее состояние. Каждое сообщение обрабатывается, изменения записываются в содержимое 
XML, и данные XML передаются дальше. Сообщения могут быть разных типов или даже 
могут быть только частично структурированными, иметь разные схемы XML, так что их 
конвертация в таблицы не всегда является простой задачей.</p>
<p>
Стандарты, основанные на XML, появляются для различных вертикальных доменов, такие, 
как финансовые и географические данные. Эти стандарты описывают структуру данных, 
зависящую от того, какие именно данные могут быть запрошены и обновлены. Довольно 
часто сами данные хранятся в двоичной форме, в то время как данные XML хранят метаданные 
об этих данных.</p>
<p>
Приведем простой пример: чтобы передать таблицу входных параметров в хранимую процедуру 
или функцию, приложение конвертирует данные в XML и передает их как параметр типа XML. 
Внутри хранимой процедуры или функции из параметра XML вновь создается набор строк.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="19"></a><b>Управление документами</b></font></p>
<p>
Предположим, что справочная служба хранит данные о пациентах и записи разговоров 
с ними в виде документа XML. Когда звонит пациент, то справочной службе нужно получить 
данные о предыдущем разговоре, чтобы знать, о чем может идти речь в текущем звонке. 
Это возможно с помощью запроса XML, что дает преимущества приложению. Т.е. облегчается 
получение информации о предыдущих разговорах и записи текущего разговора.</p>
<p>
Документы, такие, как e-mail, только частично структурированы по своей сути. Документы 
с разметкой XML легче создавать, например, с помощью Office 2003. Эти документы XML 
могут храниться в столбцах XML, индексироваться, запрашиваться и обновляться. Таким 
образом, разработчики могут делать больше со встроенной поддержкой XML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+2">
<a name="20"></a><b>Обработка XML на стороне сервера в SQL Server 2005</b></font></p>
<p>
В SQL Server 2005 Вы можете хранить в одной базе данных и реляционные данные, и данные XML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="21"></a><b>Тип данных XML</b></font></p>
<p>
Вы можете создать таблицу со столбцом XML, используя обычную команду CREATE TABLE. 
Столбец XML может быть проиндексирован особым образом.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="22"></a><b>Нетипизированный XML</b></p>
<p>
Тип данных XML в SQL Server 2005 соответствует стандарту ISO SQL-2003 типа данных XML. 
Поэтому он может хранить не только хорошо структурированные документы XML 1.0, но 
также и так называемые фрагменты контента XML с текстовыми узлами и произвольным 
количеством элементов высокого уровня. При этом выполняются проверки на структурированность 
данных, что не требует привязки данных XML к схемам XML, и плохо структурированные 
данные не принимаются.</p>
<p>
Нетипизированный XML полезен, когда схема заранее неизвестна, так что решение, основанное 
на конвертации, невозможно, а также когда схема известна, но конвертация в реляционную 
модель очень сложна и тяжела в поддержке, или когда существует множество схем, 
которые сопоставляются данным позже в зависимости от на внешних требований.</p>
<p>
<u>Пример:</u> столбец с нетипизированным XML в таблице</p>
<p>
Следующая команда создает таблицу "docs" с первичным ключом типа integer "pk" и 
столбцом с нетипизированным XML "xCol":</p>
<p></p><pre><tt>
CREATE TABLE docs (pk INT PRIMARY KEY, xCol XML not null)
</tt></pre><p></p> 
<p>
Таблица может быть создана с более чем одним XML или реляционным столбцом с наличием 
или без наличия первичного ключа.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="23"></a><b>Типизированный XML</b></p>
<p>
Если у вас есть схемы XML в коллекции схем XML, описывающие ваши данные XML, то 
вы можете сопоставить коллекцию схем XML со столбцом XML, чтобы получить типизированный 
XML. Схемы XML используются для проверки данных, выполнения более точных проверок
типа по сравнению с нетипизированным XML во время компиляции запросов и команд модификации 
данных, и оптимизации хранения и обработки запросов.</p>
<p>
Типизированные столбцы, параметры и переменные XML могут хранить документы или контент 
XML, что указывается при помощи опции (DOCUMENT или CONTENT, соответственно, CONTENT 
по умолчанию) во время объявления. Более того, вам нужно обеспечить коллекцию схем XML. 
Указывайте DOCUMENT, если каждый экземпляр XML имеет один элемент верхнего уровня, 
иначе указывайте CONTENT. Компилятор запроса, видя установленный флажок DOCUMENT, 
подразумевает, что у экземпляра XML есть только один элемент верхнего уровня.</p>
<p>
<u>Пример:</u> типизированный столбец XML в таблице</p>
<p>
Столбцы, переменные и параметры XML могут быть сопоставлены коллекции схем XML (см. 
главу "Обработка схем XML" далее в этой статье для более подробного объяснения и 
большего количества примеров). Предположим, что myCollection является такой коллекцией. 
Команда, показанная ниже, создает таблицу XmlCatalog со столбцом типизированного 
XML Document, используя myCollection. Для столбца типизированного XML также указано, 
что он может хранить и фрагменты XML, а не только документы XML.</p>
<p></p><pre><tt>
CREATE TABLE XmlCatalog ( 
  ID INT PRIMARY KEY, 
  Document XML(CONTENT myCollection))
</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="24"></a><b>Ограничения столбцов типа XML</b></p>
<p>
Кроме типизации столбца XML, Вы также можете использовать реляционные (для столбца 
или строки) ограничения на столбцах типизированного и нетипизированного XML. Вообще 
большинство ограничений SQL применимы к столбцам XML, исключениями являются ограничения 
уникального, первичного и внешнего ключей, т.к. экземпляры данных XML нельзя сравнивать. 
Таким образом, Вы можете указать, что столбец XML может или не может содержать 
значение NULL, определить у него значение по умолчанию и ограничение CHECK. Например, 
нетипизированный столбец XML может иметь ограничение CHECK для проверки, что хранимые 
экземпляры XML соответствуют схеме XML.</p>
<p>
Используйте ограничения, исходя из следующих условий:</p>
<p></p><ul><p>
</p><li><p>Ваши бизнес-правила не могут быть представлены в схемах XML. Например, адрес 
доставки заказа из цветочного магазина должен находиться в пределах 50 миль от него, 
что может быть указано в виде ограничения столбца XML. Ограничение может включать
методы для работы с типом XML.</p></li>
<li><p>Ваши ограничения включают другие XML или не XML столбцы в таблице. Например,
ограничением является требование, чтобы ID покупателя (/Customer/@CustId) в
экземпляре XML соответствовал значению столбца CustomerID типа integer.</p></li><p></p></ul><p></p>
<p>
<u>Пример:</u> ограничение столбца XML</p>
<p>
Чтобы убедиться, что фамилия автора книги отличается от его имени, можно применить 
следующее ограничение CHECK:</p>
<p></p><pre><tt>
CREATE TABLE docs (pk INT PRIMARY KEY, 
  xCol XML not null
  CONSTRAINT CK_name CHECK 
    (xCol.exist('/book/author[first-name = last-name]') = 0))
</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="25"></a><b>Кодировка текста</b></p>
<p>
SQL Server 2005 хранит данные XML в виде Unicode (UTF-16). Данные XML, полученные 
с сервера, приходят в кодировке UTF-16. Если Вы хотите другую кодировку, Вам нужно будет выполнить
необходимую конвертацию после получения данных. Например, Вы можете преобразовать 
Ваши данные XML в тип varchar на сервере, в этом случае движок базы данных выдаст 
данные XML с кодировкой, определенной типом varchar.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="26"></a><b>Хранение данных XML</b></p>
<p>
Вы можете передать значение XML для столбца, параметра или переменной XML несколькими способами.</p>
<p></p><ul><p>
</p><li><p>Как символьный или двоичный тип SQL, который неявно конвертируется в тип XML.</p></li>
<li><p>Как содержимое файла.</p></li>
<li><p>Как результат механизма публикации XML - использование FOR XML с опцией TYPE, 
которая генерирует экземпляр данных XML.</p></li><p></p></ul><p></p>
<p>
Переданное значение проверяется на структурированность. Если данные оказываются 
неструктурированными, то выдается соответствующее сообщение об ошибке.</p>
<p>
Для типизированного XML переданное значение проверяется на соответствие схемам XML, 
зарегистрированным в коллекции схем XML, сопоставленной столбцу XML. Экземпляр XML 
не вставляется в столбец, если он не проходит такую проверку. Более того, флажок 
DOCUMENT в типизированном XML ограничивает допустимые значения только документами 
XML, тогда как флажок CONTENT позволяет передавать и документ XML, и контент.</p>
<p>
<u>Пример:</u> вставка данных в нетипизированный столбец XML</p>
<p>
Следующая команда вставляет новую строку в таблицу docs со значением 1 для столбца 
pk и экземпляром &lt;book&gt; для столбца XML. Данные &lt;book&gt;, передаваемые в виде строки, 
неявно конвертируются в тип данных XML и проверяются на структурированность во время 
вставки.</p>
<p></p><pre><tt>
INSERT INTO docs VALUES (1, 
  '&lt;book genre="security" publicationdate="2002" ISBN="0-7356-1588-2"&gt;
     &lt;title&gt;Writing Secure Code&lt;/title&gt;
     &lt;author&gt;
       &lt;first-name&gt;Michael&lt;/first-name&gt;
       &lt;last-name&gt;Howard&lt;/last-name&gt;
     &lt;/author&gt;
     &lt;author&gt;
       &lt;first-name&gt;David&lt;/first-name&gt;
       &lt;last-name&gt;LeBlanc&lt;/last-name&gt;
     &lt;/author&gt;
     &lt;price&gt;39.99&lt;/price&gt;
  &lt;/book&gt;')
</tt></pre><p></p>
<p>
<u>Пример:</u> вставка данных в нетипизированный столбец XML из файла</p>
<p>
Команда INSERT, показанная ниже, получает содержимое файла C:\temp\xmlfile.xml в 
виде BLOB, используя OPENROWSET. Новая строка вставляется в таблицу docs со значением 
10 для первичного ключа и BLOB для столбца XML xCol. Проверка структурированности 
данных производится, когда содержимое файла назначается столбцу XML.</p>
<p></p><pre><tt>
INSERT INTO docs 
  SELECT 10, xCol
  FROM (SELECT * FROM OPENROWSET 
    (BULK 'C:\temp\xmlfile.xml',
      SINGLE_BLOB) AS xCol) AS R(xCol)
</tt></pre><p></p>
<p>
<u>Пример:</u> вставка данных в типизированный столбец XML</p>
<p>
Типизированный столбец XML требует, чтобы данные экземпляра XML соответствовали 
пространству имен схем XML, используемых для типизации этого столбца (пространство 
имен может быть пустым). В показанном ниже примере это делается с помощью объявления 
пространства имен xmlns=http://myDVD.</p>
<p></p><pre><tt>
INSERT XmlCatalog VALUES(2, 
  '&lt;?xml version="1.0"?&gt;
  &lt;dvdstore xmlns="http://myDVD"&gt;
    &lt;dvd genre="Comedy" releasedate="2003"&gt;
      &lt;title&gt;My Big Fat Greek Wedding&lt;/title&gt;
      &lt;price&gt;19.99&lt;/price&gt;
    &lt;/dvd&gt;
  &lt;/dvdstore&gt;')
</tt></pre><p></p>
<p>
<u>Пример:</u> сохранение данных XML, сгенерированных с помощью FOR XML с опцией TYPE</p>
<p>
FOR XML была расширена опцией TYPE, чтобы генерировать результат в виде экземпляра 
типа данных XML. Результирующий XML может быть занесен в столбец, параметр или 
переменную XML. В следующей команде экземпляр XML, сгенерированный с помощью FOR 
XML TYPE, присваивается переменной @xVar типа XML. Значение переменной можно
получить с помощью методов типа XML.</p>
<p></p><pre><tt>
DECLARE @xVar XML
SET @xVar = (SELECT * FROM docs FOR XML AUTO,TYPE)
</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="27"></a><b>Представление данных при хранении</b></p>
<p>
Экземпляры XML хранятся во внутреннем, двоичном представлении, которое
оптимизировано для эффективного парсинга. Тэги конвертируются в значения типа integer, 
и конвертированные значения хранятся во внутреннем представлении. Это дает
небольшую компрессию данных.</p>
<p>
Для нетипизированного XML значения узлов хранятся в строках Unicode (UTF-16), 
поэтому требуется конверсия типа во время работы. Например, чтобы оценить 
предикат /book/price &gt; 9.99, значение цены книги конвертируется в тип decimal. 
С другой стороны, для типизированного XML значения имеют тип, определенный 
схемами XML. Это делает парсинг данных более эффективным и позволяет избежать
конвертации типов во время работы.</p>
<p>
Двоичная форма хранения ограничена 2 гигабайтами на экземпляр XML,
что достаточно для большинства данных XML. Также глубина иерархии XML ограничена 128 уровнями.</p>
<p>
Содержимое InfoSet данных XML защищено. Оно может не быть точной копией текста XML, 
т.к. следующая информация не сохраняется: не имеющие значения пустые места,
порядок свойств, префиксы пространства имен, и объявление XML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="28"></a><b>Взгляд на моделирование данных</b></p>
<p>
Довольно часто набор реляционных столбцов и столбцов XML удобен для 
моделирования данных. Некоторые значения из ваших данных XML могут храниться в 
реляционных столбцах, а остальные, или все значения XML, хранятся в столбце XML. 
Это может дать лучшую производительность и лучшие характеристики блокировок.</p>
<p>
Значения из данных XML могут быть переданы в вычислимые столбцы в той же таблице
(это должны быть свойства с одним значением). Свойство с множеством значений
требует отдельной таблицы для свойства, которая должна заполняться с помощью триггеров.</p>
<p>
Глубина детализации данных XML, хранящихся в столбцах XML, критична для блокировок
и обновления. SQL Server использует один и то же механизм блокировки для XML и
не XML данных. Если глубина детализации велика, то блокировка больших экземпляров XML
для обновления вызывает снижение производительности при одновременной работе
множества пользователей. С другой стороны, из-за глубокой декомпозиции данных
теряется инкапсуляция объектов и увеличиваются затраты на сборку.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="29"></a><b>Выполнение запросов и модификация данных XML</b></font></p>
<p>
Выполнение запросов к экземплярам XML, хранимым в столбце XML, требует парсинга
двоичных данных XML в столбце. Парсинг двоичных данных XML производится гораздо быстрее,
чем парсинг текстовой формы данных XML. Индексирование XML позволяет избежать
повторного парсинга. Более подробно индексирование рассматривается в
главе "Индексирование данных XML".</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="30"></a><b>Методы типа XML</b></p>
<p>
Вы можете получать целые значения XML, если Вам это нужно, или можете получать 
части экземпляров XML. Это возможно с помощью четырех методов типа XML: query(), 
value(), exist() и nodes(), которые принимают в в виде аргумента выражение XQuery.
Пятый метод, modify(), позволяет изменять данные XML и принимает в виде входного
параметра команду изменения данных XML.</p>
<p>
Метод query() полезен для получения частей экземпляра XML. Выражение XQuery
сравнивается со списком узлов XML. Поддерево, получаемое на каждом из этих узлов,
возвращается в порядке документа. Тип результата - нетипизированный XML.</p>
<p>
Метод value() получает скалярное значение из экземпляра XML. Он возвращает значение 
узла, который соответствует выражению XQuery. Это значение конвертируется в тип
T-SQL, определяемый вторым параметром метода value().</p>
<p>
Метод exist() полезен для проверок существования в экземплярах XML. Он возвращает 1,
если выражение XQuery соответствует непустому списку узлов, иначе он возвращает 0.</p>
<p>
Метод nodes() выдает экземпляры специального типа XML, каждый из которых имеет 
собственный контекст, относящийся к узлу, который соотвутствует выражению XQuery.
Этот специальный тип XML поддерживает методы query(), value(), nodes() и exist(), 
и может  быть использован в агрегатах count(*) и проверках на значение NULL.
Все другие агрегаты и проверки вернут ошибку.</p>
<p>
Метод modify() позволяет изменять части экземпляра XML - добавлять или удалять
поддеревья или изменять скалярные значения. Например, изменять цену на книгу с
9.99 на 39.99.</p>
<p>
<u>Пример:</u> использование метода query()</p>
<p>
Рассмотрим следующий запрос в столбце XML xCol таблицы docs, который получает все
элементы &lt;section&gt; под элементом &lt;doc&gt; с id 123. Запрос также возвращает
значение из столбца первичного ключа с типом integer. Метод query() в списке SELECT
применяется для каждой строки в таблице, выдавая последовательность
элементов &lt;section&gt;, которые возвращаются вместе со своими поддеревьями
в порядке документов. Экземпляр XML без элемента &lt;doc&gt; с id 123
или без элемента &lt;section&gt; под ним результата не возвращает, т.е. метод query()
возвращает NULL.</p>
<p></p><pre><tt>
SELECT pk, xCol.query('/doc[@id = 123]//section')   
FROM docs
</tt></pre><p></p>
<p>
Возвращаемые значения NULL могут быть отфильтрованы во внешней команде SELECT. 
Также можно использовать метод exist(), как показано в следующем примере.</p>
<p>
<u>Пример:</u> использование метода exist()</p>
<p>
Рассмотрим следующий запрос, который использует методы query() и exist()
 в столбце
XML xCol таблицы docs. Метод exist() использует выражение пути /doc[@id =
 123],
проверяя существование элемента верхнего уровня &lt;doc&gt; со свойством
 id,
равным 123. Для каждой такой строки применяется метод query() из команды
 SELECT; в этом примере метод query() возращает последовательность
всех элементов &lt;section&gt; под элементом &lt;doc&gt;. Любая строка, в
 которой метод exist() возвращает 0, опускается.</p>
<p></p><pre><tt>
SELECT xCol.query('/doc[@id = 123]//section')   
FROM docs
WHERE xCol.exist ('/doc[@id = 123]') = 1
</tt></pre><p></p>
<p>
<u>Пример:</u> использование метода value()</p>
<p>
Следующий запрос получает заголовок третьей секции документа в виде строки Unicode, 
используя метод value(). Тип SQL nvarchar(max) результата определяется как второй 
параметр метода value(). Функция XQuery data() выделяет скалярное значение из
узла &lt;heading&gt;.</p>
<p></p><pre><tt>
SELECT xCol.value(
  'data((/doc//section[@num = 3]/heading)[1])', 
  'nvarchar(max)') 
FROM docs
</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="31"></a><b>Язык XQuery</b></p>
<p>
Существует множество источников XML из документов Office, находящихся в файловой системе, 
web сервисов и файлов конфигурации. Фактически, данные все чаще создаются либо в
формате XML, либо в виде виртуального документа XML. Чтобы справиться с этим
растущим объемом данных, был придуман мощный язык запросов XQuery. XQuery описан в спецификации XQuery Language на сайте
<a href="http://www.w3.org/TR/xquery">http://www.w3.org/TR/xquery</a> как
язык запросов, который эффективно использует структуру XML и может выражать запросы 
по всем типам данных, которые физически хранятся в виде XML или просматриваются
как XML через средний уровень. Спецификация описывает язык запросов XQuery,
который разработан для широкого применения для многих типов источников данных XML.</p>
<p>
XQuery разработан для удовлетворения требованиям XML Query 1.0 рабочей группы
W3C XML Query и примерам XML Query Use Cases. Он разработан как язык, в котором
запросы понятны и кратки. Он также достаточно гибок для выполнения запросов
широкого спектра источников данных XML, включая базы данных и документы. 
XQuery можно обобщить следующим утверждением: язык XQuery относится к XML так же, как язык SQL к реляционным базам данных.</p>
<p>
Подмножество XQuery, встроенное в T-SQL - это  язык для выполнения запросов на
типе XML. В настоящее время язык еще разрабатывается Worldwide Web Consortium (W3C)
с участием всех главных поставщиков баз данных, включая Microsoft. Наша версия соответствует релизу от ноября 2003 года.</p>
<p>
XQuery включает XPath 2.0 как язык навигации. Реализация XQuery в SQL Server 2005 
имеет конструкции для движения по узлам (for), проверки узлов (where), возврата
значений (return) и сортировки (order by). Также есть возможность изменения данных во время выполнения запросов.</p>
<p>
SQL Server 2005 также имеет языковые конструкции для изменения данных (DML) 
типа XML (для дополнительной информации см. главу "Изменение данных" ниже). 
Следующий пример показывает, как использовать XQuery для данных типа XML.</p>
<p>
<u>Пример:</u> использование богатых языковых конструкций в XQuery</p>
<p>
Следующий запрос показывает несколько языковых конструкций XQuery, используемых вместе. 
Он возвращает заголовок, обрамленный в новый тэг &lt;topic&gt; с секциями номер 3 и
далее из документа с id 123.</p>
<p></p><pre><tt>
SELECT pk, xCol.query('
  for $s in /doc[@id = 123]//section
  where $s/@num &gt;= 3
  return &lt;topic&gt;{data($s/heading)}&lt;/topic&gt;')   
FROM docs
</tt></pre><p></p>
<p>
Оператор "for" указывает на то, что нужно двигаться по всем элементам 
&lt;section&gt; под элементами &lt;doc&gt; с id 123 и привязывать
каждый такой элемент &lt;section&gt; к переменной $s. Оператор "where" 
используется для того, чтобы номер секции (атрибут @num элемента 
&lt;section&gt;)
равен или больше 3. Запрос возвращает значение секции &lt;heading&gt; по
 порядку документа, обрамленное элементом конструкции &lt;topic&gt;.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="32"></a><b>Компиляция и выполнение запроса</b></p>
<p>
Команда SQL обрабатывается анализатором SQL. Когда он обнаруживает выражение XQuery, 
управление передается компилятору XQuery, который затем компилирует выражение XQuery. Это порождает дерево запросов.</p>
<p>
Общее дерево запросов выполняет оптимизацию запросов и строит физический
 план запросов, основанный на оценке затрат. Просмотр плана показывает 
большинство 
реляционных операторов и несколько новых операторов, таких, как UDX для 
обработки XML.</p>
<p>
Выполнение запросов ориентировано на строки, как и в реляционной модели.
 Выражение WHERE применяется к каждой строке таблицы docs; это включает 
анализ
XML данных во время выполнения, чтобы применять методы типа XML. Если 
условие выполняется, то строка блокируется и выражение SELECT 
применяется
к строке. Результат выводится в виде данных XML для метода query() и 
конвертируется в соответствующий тип для метода value().</p>
<p>
Если, напротив, строка не удовлетворяет условию выражения WHERE, то она пропускается и выполнение переходит на следующую строку.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="33"></a><b>Изменение данных XML</b></p>
<p>
SQL Server 2005 имеет конструкции для изменения данных в виде расширения XQuery. 
Поддеревья могут вставляться перед или после определенного узла, или как самые
левые или самые правые потомки. Более того, поддерево может быть вставлено в
родительский узел, в этом случае оно становится самым правым потомком родителя.
Поддерживаются вставки атрибутов, элементов и текстовых узлов.</p>
<p>
Также поддерживается удаление поддеревьев. В этом случае целые поддеревья удаляются из экземпляра XML.</p>
<p>
Скалярные значения могут заменяться новыми скалярными значениями.</p>
<p>
<u>Пример:</u> вставка поддеревьев в экземпляры XML</p>
<p>
Этот пример показывает использование метода modify() для вставки нового элемента 
&lt;section&gt; справа от элемента &lt;section&gt;, чей номер равен 1.</p>
<p></p><pre><tt>
UPDATE docs SET xCol.modify('
  insert 
    &lt;section num="2"&gt;
      &lt;heading&gt;Background&lt;/heading&gt;
    &lt;/section&gt;                
  after (/doc/section[@num=1])[1]')
</tt></pre><p></p> 
<p>
<u>Пример:</u> обновление цены книги на значение $49.99</p>
<p>
Следующая команда обновления заменяет цену книги &lt;price&gt; с ISBN 1-8610-0311-0 
на новое значение $49.99. Экземпляр XML типизирован схемой XML http://myBooks,
поэтому в команде изменения данных XML объявляется пространство имен.</p>
<p></p><pre><tt>
UPDATE XmlCatalog
SET Document.modify ('
  default namespace = "http://myBooks" 
  replace value of (/bookstore/book[@ISBN=
    "1-8610-0311-0"]/price)[1] with 49.99')
</tt></pre><p></p> 
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="34"></a><b>Проверка типа и статические ошибки</b></p>
<p>
XQuery выполняет проверку типа. В фазе компиляции проверяется правильность
статического типа выражений XQuery и команд изменения данных и используются
схемы XML для ссылок на тип в случае типизированного XML. В случае нарушения
типа во время выполнения генерируются ошибки статического типа. Примерами
статических ошибок являются: добавление строки к числу, получение последовательности
значений, если ожидается единственное значение, запрос к несуществующему
узлу для типизированных данных. Явное преобразование типа используется, чтобы
избежать статических ошибок несовпадения типа. Ошибки времени выполнения XQuery
конвертируются в пустые последовательности.</p>
<p>
Параметры функций и операторы (например, eq), требующие единственного значения,
возвращают ошибку, если компилятор не может определить, гарантировано ли
единственное значение во время выполнения. Часто появляется проблема с
нетипизированными данными. Например, поиск атрибута требует единственного
родительского элемента.</p>
<p>
<u>Пример:</u> проверки типа в методе value()</p>
<p>
Следующий запрос по столбцу с нетипизированным XML требует спецификации
//author/last-name, т.к. метод value() ожидает единственный узел в качестве
первого аргумента. Без него компилятор не сможет определить, один ли узел
&lt;last-name&gt; будет найден во время выполнения:</p>
<p></p><pre><tt>
SELECT xCol.value('(//author/last-name)[1]', 'nvarchar(50)') LastName
FROM docs
</tt></pre><p></p>
<p>
Применение комбинации node()-value() для получения значений атрибутов может
не требовать спецификации, как показано в следующем примере:</p>
<p>
<u>Пример:</u> известное единственное значение</p>
<p>
Показанный ниже метод nodes() генерирует отдельную строку для каждого элемента 
&lt;book&gt;. Метод value(), применяемый на узле &lt;book&gt;, получает значение
@genre, которое, будучи атрибутом, является единственным.</p>
<p></p><pre><tt>
SELECT nref.value('@genre', 'varchar(max)') LastName
FROM docs CROSS APPLY xCol.nodes('//book') AS R(nref)
</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="35"></a><b>Междоменные запросы</b></p>
<p>
Когда Ваши данные располагаются в комбинации реляционных столбцов и столбцов XML, 
Вы можете захотеть написать запросы, которые сочетают обработку реляционных и XML 
данных. Вы можете конвертировать данные в реляционных столбцах и столбцах XML
в экземпляр XML, используя FOR XML с директивой TYPE и выполнить запрос,
используя XQuery. И наоборот, Вы можете генерировать набор строк из значений XML
и выполнить запрос, используя T-SQL, как показано в главе "Генерация набора строк из данных XML" ниже.</p>
<p>
Более удобным и эффективным путем написания междоменных запросов является использование 
значения переменной SQL или столбца внутри выражения XQuery или внутри выражения изменения данных XML:</p>
<ul>
<li><p>Вставьте значение переменной SQL в Ваше выражение XQuery или выражение XML DML, используя sql:variable().</p></li>
<li><p>Используйте значения из реляционного столбца в XQuery или контексте XML DML
с помощью sql:column().</p></li></ul>
<p>
Этот подход позволяет приложениям параметризовать запросы, как показано в
следующем примере. Sql:column() используется таким же образом и обеспечивает
дополнительные преимущества. Для повышения эффективности могут быть задействованы
индексы столбца, если это будет выбрано оптимизатором запросов. Кроме того,
можно использовать вычислимые столбцы.</p>
<p>
Тип XML и пользовательские типы не разрешены для использования с sql:variable()
и sql:column().</p>
<p>
<u>Пример:</u> междоменный запрос с использованием sql:variable()</p>
<p>
В этом запросе передается ISBN элемента &lt;book&gt; при помощи переменной SQL @isbn.
Вместо константы, переменная sql:variable() содержит значение ISBN, и запрос может 
использоваться для поиска любого ISBN, а не только того, чье значение равно 0-7356-1588-2.</p>
<p></p><pre><tt>
DECLARE @isbn varchar(20)
SET @isbn = '0-7356-1588-2'
SELECT xCol
FROM docs
WHERE xCol.exist ('/book[@ISBN = sql:variable("@isbn")]') = 1
</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="36"></a><b>Генерация набора строк из данных XML</b></p>
<p>
При управлении пользовательскими свойствами и в сценариях обмена данными
приложения довольно часто конвертируют часть данных XML в наборы строк.
Например, чтобы передать таблицу входных параметров в хранимую процедуру или
функцию, приложение конвертирует данные в XML и передает их в виде параметра XML.
Внутри хранимой процедуры или функции набор данных опять генерируется из параметра XML.</p>
<p>
Для этой цели в SQL Server 2000 есть OpenXml(). Это средство для создания 
набора строк из экземпляра XML через определение реляционной схемы для
набора строк и способа конвертации значений экземпляра XML в столбцы набора строк.</p>
<p>
И наоборот, метод nodes() может быть использован для генерации контекста узла 
внутри экземпляра XML; и контекст узла может использоваться в методах value(),
query(), exist() и nodes() для создания желаемого набора строк.
Метод nodes() получает выражение XQuery, применяет его к каждому экземпляру XML
в столбце XML, и эффективно использует индексы XML. Следующий пример показывает
использование метода nodes() для создания набора строк.</p>
<p>
<u>Пример:</u> получение свойств из экземпляра XML</p>
<p>
Предположим, Вам нужно получить имена и фамилии авторов, чье имя не "David",
в наборе строк с двумя столбцами, FirstName и LastName. Вы можете сделать
это, используя методы nodes() и value():</p>
<p></p><pre><tt>
SELECT nref.value('first-name[1]', 'nvarchar(50)') FirstName,
  nref.value('last-name[1]', 'nvarchar(50)') LastName
FROM docs CROSS APPLY xCol.nodes('//author') AS R(nref)
WHERE nref.exist('.[first-name != "David"]') = 1
</tt></pre><p></p>
<p>
В этом примере nodes('//author') порождает набор ссылок на элементы &lt;author&gt; для
каждого экземпляра XML. Имена и фамилии авторов получаются с помощью методов
value(), относящихся к этим ссылкам. Для хорошей производительности столбец XML
должен быть проиндексирован, что и является темой следующей главы.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="37"></a><b>Индексирование данных XML</b></font></p>
<p>
Данные XML хранятся во внутренней двоичной форме, и могут достигать объема в 2 гигабайта. 
Каждый запрос анализирует данные XML в каждой строке таблицы один или несколько раз
во время работы. Это приводит к замедлению обработки запроса. Если запрос часто
повторяется, то лучше проиндексировать столбец XML, хотя и нужно принять во внимание
возрастающие при этом затраты на изменение данных.</p>
<p>
Индексы XML создаются при помощи новой команды DDL на типизированных и нетипизированных 
столбцах XML. Индекс создает сбалансированное дерево по всем экземплярам XML в столбце.
Первым создаваемым индексом на столбце XML является "первичный ключ XML".
С его помощью поддерживаются три типа вторичных индексов XML на столбце XML
для ускорения часто используемых классов запросов, как показано в следующей главе.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="38"></a><b>Первичный индекс XML</b></p>
<p>
Первичный индекс XML требует наличия кластерного индекса на первичном ключе
базовой таблицы (т.е. таблицы, в которой создан столбец XML). Первичный индекс XML
создает сбалансированное дерево на поднаборе элементов Infoset узлов XML.
Столбцы сбалансированного дерева представляют тэги, такие, как названия элементов и
атрибутов, значения и типы узлов. Другие столбцы указывают порядок и структуру документов 
в данных XML и путь из корня экземпляра XML до каждого узла для эффективной оценки
выражений пути. Первичный ключ базовой таблицы дублирован в первичном индексе XML
для соответствия строк индекса со строками базовой таблицы.</p>
<p>
Тэги и названия типов из схем XML конвертируются в значения типа integer,
и конвертированные значения хранятся в сбалансированном дереве для оптимизации хранения.
Столбец пути в индексе хранит последовательность конвертированных значений в
обратном порядке, т.е. от узла до корня экземпляра XML. Обратное представление
позволяет сравнивать значения пути, если известен суффикс пути (в выражении пути,
таком, как //author/last-name).</p>
<p>
Если основная таблица секционирована, то первичный индекс XML секционируется
таким же образом, т.е. с использованием той же функции и схемы секционирования.</p>
<p>
Полные экземпляры XML получаются из столбцов XML (SELECT * FROM docs или
SELECT xCol FROM docs). Запросы, включающие методы XML, используют первичный
индекс XML и возвращают скалярные значения или поддеревья XML из самого индекса.</p>
<p>
<u>Пример:</u> создание первичного индекса XML</p>
<p>
Следующая команда создает индекс XML idx_xCol на столбце XML xCol таблицы docs:</p>
<p></p><pre><tt>
CREATE PRIMARY XML INDEX idx_xCol on docs (xCol)
</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="39"></a><b>Вторичные индексы XML</b></p>
<p>
Когда создан первичный индекс XML, можно создать вторичные индексы XML, 
чтобы ускорить выполнение запросов разных классов. Три типа вторичных 
индексов
XML - PATH, PROPERTY и VALUE - дают выигрыш в запросах, основанных на 
пути, сценариях управления пользовательскими свойствами, и запросах,
основанных на значениях, соответственно.</p>
<p>
Индекс PATH строит сбалансированное дерево на столбцах (path, value) первичного индекса XML.
Значение для пути рассчитывается из выражения пути; значение узла также используется,
если оно существует. С известными основными полями индекса PATH поиск по индексу
PATH увеличивает обработки выражения пути. Наиболее распространенным случаем
является использование метода exist() на столбцах XML в выражении WHERE команды SELECT.</p>
<p>
Индекс PROPERTY создает сбалансированное дерево на столбцах (PK, path, value)
первичного индекса XML, где PK - первичный ключ базовой таблицы. Этот индекс помогает искать значения свойств в экземпляре XML.</p>
<p>
И, наконец, индекс VALUE создает сбалансированное дерево на столбцах 
(value, path)
первичного индекса XML. Этот индекс ускоряет выполнение запросов, где 
значение
узла известно, но его путь неточно определен в запросе. Такая ситуация 
обычно возникает при поиске типа descendant-or-self, как, например,
в //author[last-name="Howard"], где элементы &lt;author&gt; могут 
встретиться на
любом уровне иерархии. Такая ситуация также возникает в запросах со 
специальными символами, таких, как /book [@* = "novel"], где запрос ищет
 элементы &lt;book&gt; с
атрибутом, имеющим значение "novel". Индекс VALUE также полезен для 
сканирования набора значений для типизированного XML.</p>
<p>
В иерархии XML может размещаться до 128 уровней; экземпляры XML, 
содержащие более длинные пути, не принимаются при вставке и изменении.</p>
<p>
Кроме этого, индексируется до 128 первых байт значения узла; более 
длинные значения размещаются внутри системы и не индексируются.</p>
<p>
<u>Пример:</u> поиск, основанный на пути</p>
<p>
Предположим, что следующий запрос часто выполняется:</p>
<p></p><pre><tt>
SELECT xCol
FROM   docs
WHERE  xCol.exist ('/book[@genre = "novel"]') = 1
</tt></pre><p></p>
<p>
Выражение пути /book/@genre и значение "novel" соответствуют ключевым полям индекса PATH.
Соответственно, вторичный индекс XML типа PATH может помочь в этом случае:</p>
<p></p><pre><tt>
CREATE XML INDEX idx_xCol_Path on docs (xCol)
  USING XML INDEX idx_xCol FOR PATH
</tt></pre><p></p>
<p>
<u>Пример:</u> получение свойств объекта</p>
<p>
Рассмотрим следующий запрос, который получает свойства "genre", "title" и
ISBN книги из каждой строки в таблице T:</p>
<p></p><pre><tt>
SELECT xCol.value ('(/book/@genre)[1]', 'varchar(50)'),
  xCol.value ('(/book/title)[1]', 'varchar(50)'),
  xCol.value ('(/book/@ISBN)[1]', 'varchar(50)')
FROM docs
</tt></pre><p></p>
<p>
В этом случае можно использовать индекс свойств:</p>
<p></p><pre><tt>
CREATE XML INDEX idx_xCol_Property on docs (xCol)
  USING XML INDEX idx_xCol FOR PROPERTY
</tt></pre><p></p>
<p>
<u>Пример:</u> запрос, основанный на значениях</p>
<p>
В следующем запросе ось потомков descendant-or-self (//) определяет частичный путь,
поэтому индекс VALUE помогает выполнять поиск, основанный на значениях ISBN:</p>
<p></p><pre><tt>
SELECT xCol
FROM   docs
WHERE  xCol.exist ('//book[@ISBN = "1-8610-0157-6"]') = 1
</tt></pre><p></p>
<p>
Индекс VALUE создается следующим образом:</p>
<p></p><pre><tt>
CREATE XML INDEX idx_xCol_Value on docs (xCol)
  USING XML INDEX idx_xCol FOR VALUE
</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="40"></a><b>Индексирование содержимого</b></p>
<p>
Вы можете создать полнотекстовый индекс на столбцах XML; это индексирует содержимое
значений XML, игнорируя разметку XML. Значения атрибутов не входят в полнотекстовый
индекс (так как они считаются частью разметки), и тэги элемента используются как
разграничительные знаки. Вы можете создавать и индексы XML, и полнотекстовые
индексы на столбце XML, и совмещать полнотекстовый поиск с использованием индекса XML.
Используйте полнотекстовый индекс в качестве первого фильтра, чтобы уменьшить выборку
и потом применить XQuery для дальнейшей фильтрации.</p>
<p>
Полнотекстовый поиск, использующий CONTAINS(), и contains() языка XQuery имеют
разную семантику. Последний метод выполняет сравнение подстроки, а первый выполняет
сравнение при помощи разграничительных знаков.</p>
<p>
<u>Пример:</u> создание полнотекстового индекса на столбце XML</p>
<p>
Шаги, требующиеся для создания полнотекстового индекса на столбце XML, не сильно
отличаются от тех, которые выполняются для столбцов других типов. В основной базе
необходим уникальный ключ на столбце. Ниже показаны команды DDL, в которых
PK__docs__7F60ED59 - первичный ключ на одном столбце таблицы:</p>
<p></p><pre><tt>
CREATE FULLTEXT CATALOG ft AS DEFAULT
CREATE FULLTEXT INDEX ON dbo.docs (xCol) KEY INDEX PK__docs__7F60ED59
</tt></pre><p></p>
<p>
<u>Пример:</u> совмещение полнотекстового поиска с запросами XML</p>
<p>
Следующий запрос проверяет, что значение XML содержит слово "Secure" в названии книги:</p>
<p></p><pre><tt>
SELECT * 
FROM   docs 
WHERE  CONTAINS(xCol,'Secure') 
AND    xCol.exist('/book/title/text()[contains(.,"Secure")]') =1
</tt></pre><p></p>
<p>
Метод CONTAINS() использует полнотекстовый индекс для выборки из документа
значений XML, которые содержат слово "Secure". Метод exist() проверяет,
что слово "Secure" содержится в названии книги.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="41"></a><b>Выполнение запроса с использованием индексов XML</b></p>
<p>
Индексы XML ускоряют выполнение запросов. Запросы всегда компилируются по
первичному индексу столбца XML, если он существует. Один план выполнения создается
для всего запроса (и для реляционной части, и для части XML), который оптимизируется
при помощи оптимизатора запросов движка базы данных. Вторичные индексы XML выбираются
для использования в соответствии с оценками затрат оптимизатора запросов.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="42"></a><b>Каталожные представления для индексов XML</b></p>
<p>
Каталожные представления используются для просмотра индексов XML с типом индекса 3
(столбец "type"). В столбце "name" содержится название индекса XML.</p>
<p>
Индексы XML также находятся в каталожном представлении sys.xml_indexes, в котором
содержатся все столбцы из sys.indexes и несколько дополнительных, имеющих отношение
к индексам XML. Значение NULL в столбце "secondary_type" указывает на первичный
индекс XML; значения 'P', 'R' and 'V' соответствуют вторичным индексам XML PATH,
PROPERTY и VALUE.</p>
<p>
Использование пространства в индексах XML может быть проверено при помощи табличной
функции sys.fn_indexinfo(). Функция возвращает такую информацию, как количество
занятых страниц на диске, средний размер строки в байтах, количество записей,
и другую информацию для индексов всех типов, включая индексы XML. Эта информация
доступна для каждой секции базы данных; индексы XML используют ту же схему
секционирования и функцию секционирования базовой таблицы.</p>
<p>
<u>Пример:</u> использование пространства в индексах XML</p>
<p></p><pre><tt>
SELECT sum(Pages)
FROM   sys.fn_indexinfo ('docs', 'idx_xCol_Path' , DEFAULT, 'DETAILED')
</tt></pre><p></p>
<p>
Эта команда SELECT выводит количество страниц на диске, занятых индексом XML
idx_xCol_Path в таблице T по всем секциям. Без функции sum() результат возвратил
бы количество занятых страниц на диске по каждой секции.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="43"></a><b>Обработка схем XML</b></font></p>
<p>
Использование схем XML необязательно. Как уже упоминалось ранее, данные типа XML,
не привязанные к схемам XML, являются нетипизированными; значения узла XML
хранятся в виде строк Unicode, и экземпляры XML проверяются на корректность.
Нетипизированный столбец XML может быть индексированным.</p>
<p>
Превращение данных XML в типизированные данные производится с помощью привязки
данных XML к схемам XML, зарегистрированным в коллекции схем XML. Новая команда DDL
позволяет создать коллекцию схем XML, в которой можно зарегистрировать одну или
несколько схем XML. Столбец, параметр или переменная XML, привязанные к коллекции
схем XML, являются типизированными в соответствии со всеми схемами XML в коллекции.
Внутри коллекции схем XML система типов определяет каждую схему XML, используя ее
пространство имен.</p>
<p>
Каждый элемент XML верхнего уровня в экземпляре XML должен определять пространство
имен (возможно, пустое), которое ему соответствует. Данные проверяются на соответствие
пространству имен каждого элемента во время вставки и изменения. Двоичное представление
XML кодирует типизированные значения на основе информации соответствующей схемы XML,
поэтому анализ XML в данном случае является более эффективным по сравнению с
нетипизированным XML, т.к..значения в индексах XML имеют правильный тип
(/book/price хранится как decimal, если определено в схеме XML как xs:decimal).</p>
<p>
Во время компиляции запроса схемы XML используются для проверки типа, и в случае
несоответствия типов генерируются ошибки. Компилятор запросов также использует
схемы XML для оптимизации запросов.</p>
<p>
Подсистема метаданных ядра базы данных содержит информацию о типе XML, такую, как
коллекции схем XML и содержащиеся в них схемы, а также конвертацию между XSD и
реляционными системой. Поддерживается почти вся спецификация W3C XML Schema 1.0
(для дополнительной информации смотрите
<a href="http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/">
http://www.w3.org/TR/2001/REC-xmlschema-1-20010502/</a> и
<a href="http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/">
http://www.w3.org/TR/2001/REC-xmlschema-2-20010502/</a>).
Комментарии и аннотации в документах схем XML не защищены и key/keyref не поддерживается.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="44"></a><b>Коллекция схем XML</b></p>
<p>
Коллекция схем XML - это объект метаданных, ограниченная реляционной схемой и
содержащая одну или более схем XML, которые могут быть связанными (например,
используя &lt;xs:import&gt;) или несвязанными. Индивидуальные схемы внутри коллекции
схем XML определяются с помощью их пространства имен. Коллекции схем XML -
это защищенные как таблицы объекты.</p>
<p>
Коллекция схем XML создается с помощью CREATE XML SCHEMA COLLECTION и содержит
одну или более схем XML. После этого Вы можете типизировать столбец XML, используя
коллекцию схем XML. Такой дизайн приводит к гибкой модели данных, в которой
значения XML, типизированные в соответствии с разными схемами XML, могут храниться
в одном и том же столбце. Это особенно удобно, когда количество схем XML большое.
Более того, такой дизайн до некоторой степени поддерживает развитие схемы XML.</p>
<p>
Кроме того, опция DOCUMENT / CONTENT в типизированном столбце XML определяет,
что в столбце XML могут храниться деревья XML или фрагменты XML, соответственно.
Значение по умолчанию - CONTENT. Для значения DOCUMENT каждый экземпляр XML должен
определять пространство имен его элемента верхнего уровня, в соответствии с которым
он проверяется и типизируется. С другой стороны, для CONTENT каждый элемент верхнего
уровня может определять любое из пространств имен в коллекции схем XML. Экземпляр
XML проверяется и типизируется в соответствии со всеми пространствами имен,
имеющимися в экземпляре.</p>
<p>
<u>Пример:</u> создание коллекции схем XML</p>
<p>
Предположим, что Вы хотите использовать схему XML с пространством имен http://myBooks,
чтобы типизировать ваши экземпляры XML. Создайте коллекцию схем XML myCollection и
добавьте в нее схему XML, как показано ниже:</p>
<p></p><pre><tt>
CREATE XML SCHEMA COLLECTION myCollection AS 
'&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns="http://myBooks"
   elementFormDefault="qualified"
  targetNamespace="http://myBooks"&gt;
  &lt;xsd:element name="bookstore" type="bookstoreType" /&gt;
  &lt;xsd:complexType name="bookstoreType"&gt;
   &lt;xsd:sequence maxOccurs="unbounded"&gt;
     &lt;xsd:element name="book" type="bookType" /&gt;
   &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="bookType"&gt;
   &lt;xsd:sequence&gt;
     &lt;xsd:element name="title" type="xsd:string" /&gt;
     &lt;xsd:element name="author" type="authorName" /&gt;
     &lt;xsd:element name="price" type="xsd:decimal" /&gt;
   &lt;/xsd:sequence&gt;
   &lt;xsd:attribute name="genre" type="xsd:string" /&gt;
   &lt;xsd:attribute name="publicationdate" type="xsd:string" /&gt;
   &lt;xsd:attribute name="ISBN" type="xsd:string" /&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="authorName"&gt;
   &lt;xsd:sequence&gt;
     &lt;xsd:element name="first-name" type="xsd:string" /&gt;
     &lt;xsd:element name="last-name" type="xsd:string" /&gt;
   &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;'</tt></pre><p></p>
<p>
Новый объект метаданных создается для myCollection, в которой регистрируется схема XML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="45"></a><b>Изменение коллекции схем XML</b></p>
<p>
Команда ALTER XML SCHEMA COLLECTION поддерживает расширение схемы XML в коллекции
схем XML новыми компонентами схемы верхнего уровня и регистрацию новых схем XML
в коллекции схем XML. Это показано в следующем примере:</p>
<p>
<u>Пример:</u> изменение коллекции схем XML</p>
<p>
Следующая команда показывает, как новая схема XML с пространством имен http://myDVD
может быть добавлена к коллекции схем XML myCollection:</p>
<p></p><pre><tt>
ALTER XML SCHEMA COLLECTION myCollection ADD
'&lt;xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns="http://myDVD"
   elementFormDefault="qualified"
  targetNamespace="http://myDVD"&gt;
  &lt;xsd:element name="dvdstore" type="dvdstoreType" /&gt;
  &lt;xsd:complexType name="dvdstoreType"&gt;
   &lt;xsd:sequence maxOccurs="unbounded"&gt;
     &lt;xsd:element name="dvd" type="dvdType" /&gt;
   &lt;/xsd:sequence&gt;
  &lt;/xsd:complexType&gt;
  &lt;xsd:complexType name="dvdType"&gt;
   &lt;xsd:sequence&gt;
     &lt;xsd:element name="title" type="xsd:string" /&gt;
     &lt;xsd:element name="price" type="xsd:decimal" /&gt;
   &lt;/xsd:sequence&gt;
   &lt;xsd:attribute name="genre" type="xsd:string" /&gt;
   &lt;xsd:attribute name="releasedate" type="xsd:string" /&gt;
  &lt;/xsd:complexType&gt;
&lt;/xsd:schema&gt;'</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="46"></a><b>Каталожные представления для коллекций схем XML</b></p>
<p>
Каталожные представления SQL коллекций схем XML позволяют пользователям перестраивать
содержимое индивидуальных пространств имен схем XML. Коллекции схем XML перечислены
в каталожном представлении sys.xml_schema_collections. Коллекция схем
XML "sys" определена системой и содержит предопределенные пространства имен, 
которые могут использоваться во всех пользовательских коллекциях схем XML без потребности
явно загружать их. Эти пространства имен включают в себя пространства имен
для xml, xs, xsi, fn и xdt.</p>
<p>
Два других каталожных представления, заслуживающих внимания: sys.xml_schema_namespaces,
которое перечисляет все пространства имен внутри каждой коллекции схем XML; и
sys.xml_components, которое перечисляет все компоненты схемы XML внутри каждой схемы XML.</p>
<p>
В встроенную функцию XML_SCHEMA_NAMESPACE() можно передать имя реляционной схемы,
коллекции схем XML или пространство имен схемы XML. Функция возвращает экземпляр XML,
содержащий схему XML. Если аргумент пространства имен не передан, встроенная функция
возвращает экземпляр XML, который содержит все схемы XML в коллекции схем XML,
кроме предопределенных схем XML.</p>
<p>
<u>Пример:</u> получение списка пространств имен XML в коллекции схем XML.</p>
<p>
Используйте следующий запрос для коллекции схем XML "myCollection":</p>
<p></p><pre><tt>
SELECT XSN.name
FROM    sys.xml_schema_collections XSC 
 JOIN sys.xml_schema_namespaces XSN ON 
(XSC.xml_collection_id = XSN.xml_collection_id)
WHERE    XSC.name = 'myCollection'</tt></pre><p></p>
<p>
<u>Пример:</u> получение определенной схемы XML из коллекции схем XML.</p>
<p>
Следующая команда позволяет получить  схему XML с пространством имен http://myBooks
из коллекции схем XML "myCollection" внутри реляционной схемы dbo.</p>
<p></p><pre><tt>
SELECT XML_SCHEMA_NAMESPACE (N'dbo', N'myCollection', 
N'http://myBooks')</tt></pre><p></p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="47"></a><b>Контроль доступа к коллекциям схем XML</b></p>
<p>
Коллекции схем XML могут быть защищены, как любой объект SQL, используя модель
безопасности SQL Server 2005. Вы можете дать пользователю права на создание
коллекций схем XML внутри базы данных. Каждая коллекция схем XML поддерживает
разрешения ALTER, CONTROL, TAKE OWNERSHIP, REFERENCES, EXECUTE и VIEW DEFINITION.</p>
<p>
Разрешение ALTER нужно для выполнения команды ALTER XML SCHEMA COLLECTION.</p>
<p>
Разрешение TAKE OWNERSHIP нужно для передачи владения коллекцией схем XML от
одного пользователя к другому при помощи команды ALTER AUTHORIZATION.</p>
<p>
Разрешение REFERENCES дает пользователю возможность использовать коллекции схем XML,
когда требуется привязка схемы, например, для типизирования или ограничения столбцов
и параметров XML.</p>
<p>
Разрешение EXECUTE требуется для проверки при помощи коллекции схем XML значений,
вставленных или обновленных пользователем. Это также нужно для выборки значений
из типизированных столбца, переменной и параметра XML, используя тип данных XML.</p>
<p>
Разрешение VIEW DEFINITION дает пользователю доступ к строкам в каталожных
представлениях, имеющих отношение к коллекциям схем XML, всем содержащимся
в коллекциях схемам, и всем компонентам, содержащимся в схемах XML.</p>
<p>
Разрешение CONTROL позволяет пользователю выполнять любые операции над коллекцией
схем XML, включая удаление коллекции схем XML, используя команду DROP XML SCHEMA COLLECTION.
Это разрешение влияет на другие разрешения на коллекции схем XML.</p>
<p>
Права доступа на коллекцию схемы XML требуются в дополнение к другим правам доступа
на  таблице или столбце XML. Пользователю требуются права доступа для создания таблиц
и разрешение REFERENCES на коллекции схем XML C, чтобы создать таблицу T со
столбцом XML X, типизированным согласно C. Пользователь с разрешением на вставку
данных в столбец X может делать это, если у него также есть разрешение EXECUTE
на коллекции схем XML C. Аналогично, пользователю требуется разрешение SELECT на
столбце X и разрешение EXECUTE на C для выборки данных из столбца X, используя
методы XML. Однако, разрешение SELECT на X достаточно для получения полных
значений XML из столбца X, таких, как SELECT X FROM T или SELECT * FROM T.</p>
<p>
Разрешения могут быть отозваны у пользователя, и пользователю могут быть запрещены
права доступа, согласно модели безопасности SQL Server 2005.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="48"></a><b>Видимость каталожных представлений</b></p>
<p>
Пользователь, имеющий разрешения ALTER, TAKE OWNERSHIP, REFERENCES, VIEW DEFINITION
или CONTROL на коллекции схем XML, имеет доступ к строкам каталожных представлений,
относящихся к коллекции схем XML, содержащимся в коллекции схемам XML, и их компонентам.
Пользователь также имеет доступ к содержимому коллекции схем XML при помощи
встроенной функции XML_SCHEMA_NAMESPACE().</p>
<p>
Если пользователю запрещено разрешение VIEW DEFINITION, то пользователь не имеет
доступа к коллекции схем XML при помощи каталожных представлений или функции
XML_SCHEMA_NAMESPACE().</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="49"></a><b>Улучшения в FOR XML</b></font></p>
<p>
Директива TYPE создает экземпляр XML, который может быть присвоен столбцу,
переменной или параметру XML, или может быть выбран, используя методы XML.</p>
<p>
Режим PATH позволяет пользователю определять путь в дереве XML, где должны
находиться значения столбцов, что более удобно, чем FOR XML EXPLICIT, хотя
этот режим и не может работать с глубокими иерархиями.</p>
<p>
Директива XSINIL, используемая в связке с ELEMENTS, конвертирует NULL в элемент
с атрибутом xsi:nil="true". Новая директива ROOT позволяет определять
корневой узел во всех режимах FOR XML. Новая директива XMLSCHEMA создает внутреннюю схему XSD.</p>
<p>
Для дополнительной информации об улучшениях в FOR XML, смотрите
статью "<a href="http://msdn.microsoft.com/XML/BuildingXML/XMLandDatabase/default.aspx?pull=/library/en-us/dnsql90/html/forxml2k5.asp">
What's New in FOR XML in Microsoft SQL Server</a>" Michael Rys, опубликованную в MSDN в июне 2004.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="50"></a><b>Руководство по производительности</b></font></p>
<p>
Модель данных XML более сложна и богата, чем реляционная. Модель данных XML не
только позволяет вам моделировать сложные данные, но она должна также защищать
иерархические отношения и порядок документов внутри данных. Порядок документа
поддерживается сортировкой, основанной на идентификаторах узлов XML; это также
поддерживает иерархические отношения. Это приводит к более сложному плану выполнения.</p>
<p>
Для лучшей производительности структурированные данные должны храниться в
реляционных столбцах таблиц. Выбирайте модель данных XML, если Ваши данные
частично структурированы или неструктурированны, и содержат разметку XML,
но не ожидайте улучшения производительности. Схемы XML помогают в оптимизации запросов.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="51"></a><b>Поддержка XML в SQL Server CLR</b></font></p>
<p>
Используя поддержку SQL Server CLR, вы можете писать логику на серверной стороне в
управляемом коде для поддержки бизнес-правил. Бизнес-логика может быть добавлена
в данные XML следующими способами:</p>
<p>
Вы можете писать функции SQLCLR в управляемом коде, в который вы передаете значения XML,
и использовать возможности обработки XML, предоставленные пространством имен System.Xml.
Ниже показан пример трансформации XSL в данные XML. Вы также можете разложить XML
на один или больше управляемых классов и оперировать ими, используя управляемый код.
Вы можете написать хранимые процедуры и функции T-SQL, которые вызывают обработку
столбца XML.</p>
<p>
<u>Пример:</u> применение трансформации XSL</p>
<p>
Рассмотрим функцию CLR TransformXml(), которая принимает в качестве аргумента экземпляр 
XML и трансформацию XSL, применяет трансформацию к данным XML, 
и возвращает измененный XML. Схематично функция, написанная на C#, выглядит следующим 
образом:</p>
<p></p><pre><tt>
public static SqlXml TransformXml (SqlXml XmlData, string xslPath) {
   // Load XSL transformation
   XslTransform xform = new XslTransform();
   XPathDocument xslDoc = new XPathDocument (xslPath);
   xform.Load (xslDoc.CreateNavigator(),null);

   // Load XML data
   XPathDocument xDoc = new XPathDocument (XmlData.CreateReader());
   XPathNavigator nav = xDoc.CreateNavigator ();

   // Return the transformed value
   SqlXml retSqlXml = new SqlXml (xform.Transform(nav, null));
   return (retSqlXml);
}
</tt></pre><p></p>
<p>
Когда сборка зарегистрирована и создана пользовательская функция T-SQL SqlXslTransform(), 
соответствующая функции CLR TransformXml(), то эта функция может быть вызвана из T-SQL
следующим запросом:</p>
<p></p><pre><tt>
SELECT SqlXslTransform (xCol, 'C:\yukon\xsltransform.xsl')
FROM    T
WHERE  xCol.exist('/book/title/text()[contains(.,"custom")]') =1
</tt></pre><p></p>
<p>
Результат запроса содержит набор записей трансформированного XML.</p>
<p>
SQLCLR открывает новые возможности по разложению данных XML в таблицы и
запрашиванию данных XML, используя управляемые классы в пространстве 
имен System.Xml. Дополнительную информацию вы сможете найти в системах справки
SQL Server 2005 и Visual Studio® 2005.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+2">
<a name="52"></a><b>Обработка XML на стороне клиента в SQL Server 2005</b></font></p>
<p><font color="#330066" size="+1">
<a name="53"></a><b>Поддержка XML на стороне клиента</b></font></p>
<p>
<a name="54"></a><b>Поддержка ADO.NET XML в .NET Framework V2.0</b></p>
<p>
Тип XML рассматривается как класс SqlXml в пространстве имен System.Data.SqlTypes 
метода SqlDataReader.GetSqlXml(). Вы можете получить XmlReader из объекта SqlXml,
используя функцию SqlXml.CreateReader().</p>
<p>
Имя коллекции схем XML, состоящее из трех частей, которая типизирует столбец XML,
можно получить из метаданных столбца XML (используя GetSchemaTable() или GetSqlMetaData (int) 
объекта SqlDataReader) в виде трех свойств, содержащих имя базы данных  
(XmlSchemaCollectionDatabase), реляционную схему (XmlSchemaCollectionOwingSchema)
и коллекцию схем XML (XmlSchemaCollectionName).</p>
<p>
Новый набор данных схемы XMLSCHEMA доступен пользователям для получения схем XML с
сервера. Набор данных XMLSCHEMA содержит три столбца для коллекции схем XML,
пространства имен, и самого содержимого схемы XML.</p>
<p>
Следующие примеры показывают код для управляемого доступа к данным XML.</p>
<p>
<u>Пример:</u> встроенный доступ к данным XML</p>
<p>
Код на C#, показанный ниже, демонстрирует, как можно получить доступ к данным XML из  
встроенного провайдера. Код для доступа клиента SQL требует встроенного доступа.</p>
<p></p><pre><tt>
using System;
using System.Xml;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlServer;

class xmldtADONETReadAccessInProc
{
   static void ReadXmlDataType () {
      // Встроенное соединение с сервером
      SqlConnection conn = SqlContext.GetConnection();

      // Подготовка запроса для выборки данных XML
      SqlCommand cmd = conn.CreateCommand();
      cmd.CommandText = "SELECT xCol FROM docs";

      // Выполнение запроса и получение данных
      SqlDataReader r = cmd.ExecuteReader();
      r.Read();

      // Доступ к столбцу с данными XML в наборе данных
      SqlXml xml = r.GetSqlXml(0);
      new XmlTextWriter(Console.Out).WriteNode( 
xml.CreateReader(), true);
   }
}
</tt></pre><p></p>
<p>
<u>Пример:</u> обновление столбца XML с использованием клиентского провайдера SQL</p>
<p>
Код ниже демонстрирует метод WriteXmlDataType(), который изменяет значение столбца XML, 
используя клиентский провайдер SQL. Код для встроенного провайдера такой же.</p>
<pre><tt>
using System;
using System.Xml;
using System.Data;
using System.Data.SqlTypes;
using System.Data.SqlClient;

class xmldtADONETUpdateAccess
{
   static void WriteXmlDataType () {
      // Соединение с сервером
      SqlConnection conn = new SqlConnection("server=server1;" +
" database=XMLtest; Integrated Security=SSPI");
      conn.Open();

   // Обновление столбца XML на сервере
   SqlCommand cmd = conn.CreateCommand();
   cmd.CommandText = "UPDATE docs SET xCol=@x WHERE id=1";

// Установка значения параметра XML
   SqlParameter p = cmd.Parameters.Add("@x", SqlDbType.Xml);
p.Value = new SqlXml(new XmlTextReader("&lt;hello/&gt;", 
XmlNodeType.Document, null));

// Выполнение обновления и закрытие соединения
   cmd.ExecuteNonQuery();
conn.Close();
}
}
</tt></pre>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="55"></a><b>Встроенный клиентский доступ к SQL</b></p>
<p>
В провайдере OLE DB нового встроенного доступа к SQL (SQLNCLI) столбец XML
может быть получен как в виде строки Unicode (DBTYPE_XML, DBTYPE_BSTR,
DBTYPE_WSTR и DBTYPE_VARIANT), так и в виде потока символов Unicode,
используя ISequentialStream. По умолчанию используется DBTYPE_XML.</p>
<p>
Имя коллекции схем XML, состоящее из трех частей, передается тремя новыми столбцами 
в наборе данных схемы COLUMNS, возвращаемом IDBSchemaRowset::GetRowset(): столбцом
SS_XML_CATALOGNAME, передающим название каталога; столбцом SS_XML_SCHEMANAME, передающим 
имя реляционной схемы, в которой размещается коллекция схем XML, и столбцом
SS_XML_SCHEMACOLLECTIONNAME, передающим имя коллекции схем XML.
Эти имена принадлежат типу DBTYPE_WSTR. Столбцы имеют значение NULL
для нетипизированного столбца XML.</p>
<p>
Такие же изменения были сделаны в наборе данных схемы PROCEDURE_PARAMETERS и в
IColumnRowset:GetColumnRowset().</p>
<p>
Чтобы получить содержимое коллекции схем XML, клиент может создать отдельный доступ 
к серверу, используя эти имена в вызове XML_SCHEMA_NAMESPACE(), и получить
схемы XML в виде данных XML. Также IDBSchemaRowset с новым набором данных схемы 
SS_XMLSCHEMA возвращает имя каталога, имя реляционной схемы, имя коллекции схем XML, 
пространство имен и схему XML.</p>
<p>
Для доступа ODBC с помощью SQLNCLI, данные XML конвертируются в символьные данные 
Unicode, называемые SQL_SS_XML. Имя коллекции схем XML, состоящее из трех частей,
передается через SqlColAttribute для столбца XML CharacterAttributePtr.
Идентификаторы полей следующие: SQL_DESC_SS_XML_SCHEMA_CATALOG_NAME,
SQL_DESC_SS_XML_SCHEMA_SCHEMA_NAME и SQL_DESC_SS_XML_SCHEMA_COLLECTION_NAME
для имен базы данных, реляционной схемы и коллекции схем XML, соответственно.</p>
<p>
Пользователи должны устанавливать сервер базы данных или клиентские инструменты 
SQL Server 2005, чтобы получить встроенный клиентский доступ к SQL.
Доступ OLE DB к данным XML, с использованием MDAC 2.8 ADO, невозможен.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="56"></a><b>Конвертация SQLXML между XML и реляционными схемами</b></font></p>
<p>
Вы можете создать логические представления XML Ваших реляционных данных, используя 
технологию конвертации SQLXML. Представление XML, также называемое "конвертацей" 
или "аннотируемой схемой", создается с помощью добавления специальных аннотаций к 
существующей схеме XSD. После этого другие технологии SQLXML могут использовать эту 
аннотируемую схему для трансформации запросов и обновлений логического
представления XML в запросы и обновления реляционных таблиц:</p>
<p>
Когда представление XML комбинируется с запросом XPath, SQLXML сгенерирует запрос FOR XML, 
чтобы найти запрошенные данные и оформить их, как определено в схеме.
Апдейтаграммы SQLXML отражают изменения в экземпляре XML, который, будучи совмещенным 
с аннотируемой схемой, вносит эти изменения в реляционную структуру с
оптимистической блокировкой, чтобы удостовериться, что обновились нужные данные.
SQLXML Bulkload использует представление XML, чтобы "разрезать" данные XML на 
реляционные таблицы. Для дополнительной информации обратитесь к документации по SQLXML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="57"></a><b>Создание представления XML реляционных таблиц</b></p>
<p>
Чтобы создать представление XML базы данных, начните со схемы XSD для ваших данных XML.
Строки таблицы/представления базы данных будут конвертироваться в элементы сложного 
типа в схеме. Значения столбцов в базе данных конвертируются в атрибуты или
элементы простого типа.</p>
<p>
По умолчанию, если не задано явных аннотаций, SQLXML предполагает, что элементы сложного 
типа будут конвертироваться в таблицы, а элементы простого типа и атрибуты - в столбцы.
Это работает, только если имена элементов и атрибутов точно соответствуют именам
таблиц и столбцов в Вашей базе данных.</p>
<p>
Если имя элемента/атрибута не такое, как имя таблицы/представления или имя столбца,
с которым он конвертируется, то должна быть создана явная конвертация. Следующие аннотации
используются для определения конвертации между элементом или атрибутом в документе XML
и таблицей (представлением) или столбцом в базе данных:</p>
<p>
* sql:relation - конвертирует элемент XML в таблицу базы данных.<br>
* sql:field - конвертирует элемент или атрибут в столбец базы данных.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="58"></a><b>Конвертация отношений для создания иерархий в представлениях XML</b></p>
<p>
В Вашей базе данных таблицы могут быть связаны внешними ключами.
В XML эти же отношения отражаются в виде иерархии элементов. Чтобы создать
правильную иерархию в Вашей конвертации, Вы должны определить, как элементы 
связаны между собой. Вы можете установить эти связи между элементами схемы конвертации,
используя аннотацию sql:relationship. В этой аннотации Вы можете определить родительские 
и дочерние таблицы, как и столбцы в каждой из них, которые должны использоваться 
для выполнения объединения. Тогда SQLXML будет использовать эту информацию для 
создания правильной иерархии для вашей конвертации.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="59"></a><b>Использование столбца overflow для хранения нераспределенных данных</b></p>
<p>
Конвертация работает, когда Ваши данные XML имеют постоянную структуру. Однако, 
могут быть некоторые данные в Вашем XML, которые или не структурированы, или не 
конвертируются в специальный столбец. Для хранения этих данных и дальнейшего их 
получения может использоваться аннотация sql:overflow. Аннотация sql:overflow 
определяет столбец, в котором хранится вся нераспределенная информация, и из
которого ее можно получить запросами.</p>
<p>
Столбец overflow также подходит для расширения XML без необходимости добавления 
нового столбца в Вашу базу данных. Элементы и атрибуты могут быть добавлены
к Ввашей структуре XML в любое время без добавления столбцов для их хранения
в базе данных. Они просто будут храниться в поле overflow, и могут быть
получены в нужное время.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="60"></a><b>Дополнительная информация</b></p>
<p>
Для дополнительной информации по созданию представлений XML и примеров конвертации
смотрите "<a href="http://msdn.microsoft.com/SQL/sqlreldata/XML/default.aspx?pull=/library/en-us/sqlxml3/htm/ssxsdannotations_0gqb.asp">Создание представлений XML с помощью аннотируемых схем XSD</a>".</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="61"></a><b>Выполнение запросов к представлениям XML с использованием XPath</b></font></p>
<p>
Создав представление XML в базе данных, Вы можете выполнять запросы к
этому представлению так же, как если бы действительно существовал документ XML,
используя язык запросов XPath. SQLXML поддерживает подмножество языка запросов XPath 1.0.
Когда XPath используется вместе с конвертацией, SQLXML создает команду
FOR XML EXPLICIT, которая посылается в SQL Server. Результирующие данные
получаются и форматируются в соответствии с конвертацией.</p>
<p>
Для дополнительной информации о подиножестве XPath, поддерживаемом представлениями
XML, смотрите документацию о SQLXML.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="62"></a><b>Обновление через представления XML с использованием апдейтаграмм</b></font></p>
<p>
Вы можете изменять (вставлять, обновлять или удалять) данные в базе данных SQL Server 
через представление XML, используя апдейтаграмму на представлении XML Вашей базы данных.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="63"></a><b>Структура апдейтаграммы</b></p>
<p>
Апдейтаграмма - это документ XML с элементами &lt;sync&gt;, &lt;before&gt; и
&lt;after&gt;, которые формируют синтаксис апдейтаграммы.
Каждый блок &lt;sync&gt; содержит один или более блоков &lt;before&gt; и
&lt;after&gt;. &lt;before&gt; отражает существующее состояние (также называемое
"состояние до") экземпляра записи. &lt;after&gt; определяет новое состояние
после изменения данных. Удаляет ли апдейтаграмма экземпляр записи, вставляет его или
обновляет, зависит от содержимого блоков &lt;before&gt; и &lt;after&gt;.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="64"></a><b>Операции вставки</b></p>
<p>
Апдейтаграмма указывает на операцию вставки, если экземпляр записи появляется
в блоке &lt;after&gt;, но отсутствует в соответствующем блоке &lt;before&gt;.
В этом случае апдейтаграмма вставляет запись из блока &lt;after&gt; в базу данных.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="65"></a><b>Операции удаления</b></p>
<p>
Апдейтаграмма указывает на операцию удаления, если экземпляр записи появляется
в блоке &lt;before&gt;, но отсутствует в соответствующем блоке &lt;after&gt;.
В этом случае апдейтаграмма удаляет из базы данных запись из блока &lt;before&gt;.</p>
<p>
If an element that is specified in the updategram either matches more than one row 
in the table or does not match any table row, the updategram returns an error and 
cancels the entire &lt;sync&gt; block. Only one record at a time can be deleted by an 
element in the updategram.
</p><p>
Если элемент, который определен в апдейтаграмме совпадает с более чем одной строкой 
в таблице или не совпадает ни с одной строкой, то апдейтаграмма возвращает ошибку и
отменяет выполнение всего блока &lt;sync&gt;. За один раз при помощи элемента 
апдейтаграммы можно удалить только одну запись.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="66"></a><b>Операции обновления</b></p>
<p>
Когда Вы обновляете существующие данные, Вы должны определить оба
блока &lt;before&gt; и &lt;after&gt;. Апдейтаграмма использует элементы,
которые определены в блоке &lt;before&gt;, чтобы идентифицировать существующие
записи в базе данных. Соответствующие элементы в блоке &lt;after&gt; показывают,
как должны выглядеть записи после выполнения операции обновления.</p>
<p>
Элемент в блоке &lt;before&gt; должен совпадать только с одной строкой таблицы
в базе данных. Если элемент совпадает с множеством строк талблицы или не совпадает
ни с одной строкой, то апдейтаграмма возвращает ошибку и отменяет выполнение
всего блока &lt;sync&gt;.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="67"></a><b>Дополнительная информация</b></p>
<p>
Для дополнительной информации о создании и использовании апдейтаграмм для изменения 
данных через представления XML
смотрите <a href="http://msdn.microsoft.com/SQL/sqlreldata/XML/default.aspx?pull=/library/en-us/sqlxml3/htm/updategram_5kkh.asp">
Использование апдейтаграмм для изменения данных</a>.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="68"></a><b>Bulk загрузка данных XML через представления XML</b></font></p>
<p>
Bulk загрузка XML - это COM-объект, который позволяет Вам загружать данные XML
в таблицы SQL Server. Вы можете вставлять данные XML в базу данных SQL Server, используя 
команду INSERT и функцию OPENXML; однако утилита bulk загрузки обеспечивает более 
высокую производительность, когда Вам нужно вставить большое количество данных XML. 
Bulk загрузка XML обрабатывает схему конвертации и определяет таблицы, в которые нужно 
вставить данные XML. Затем она заносит данные XML в реляционные таблицы.</p>
<p>
Т.к. исходный документ XML может быть большим, весь документ не читается 
в память для выполнения bulk загрузки. Вместо этого bulk загрузка представляет
данные XML в виде потока и читает его. Когда утилита читает данные, она определяет
таблицы базы данных, создает нужные записи из источника данных XML и после этого
отправляет записи в SQL Server для вставки.</p>
<p>
Для дополнительной информации о работе и использовании bulk загрузки 
смотрите <a href="http://msdn.microsoft.com/SQL/sqlreldata/XML/default.aspx?pull=/library/en-us/sqlxml3/htm/bulkload_7pv0.asp">
Выполнение bulk загрузки данных XML</a>.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="69"></a><b>Методы доступа к данным SQLXML</b></font></p>
<p>
По сравнению с SQL Server 2000 были добавлены два новых способа использования
функциональности SQLXML:</p>
<ul>
<li><p>Управляемые классы SQLXML</p></li>
<li><p>Сетевые службы SQLXML</p></li></ul>
<p>
Кроме того, доступ HTTP к SQL Server был улучшен для обеспечения поддержки
апдейтаграмм в шаблонах.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="70"></a><b>Управляемые классы SQLXML</b></p>
<p>
Управляемые классы SQLXML обеспечивают функциональность SQLXML 3.0 в Microsoft .NET Framework.
Используя управляемые классы SQLXML, Вы можете написать приложение C# для того,
чтобы получить доступ к данным XML из экземпляра SQL Server, вытащить данные
в среду .NET Framework, обработать их и отправить обновления обратно в SQL Server.</p>
<p>
Для дополнительной информации об использовании управляемых классов SQLXML
смотрите <a href="http://msdn.microsoft.com/SQL/sqlreldata/XML/default.aspx?pull=/library/en-us/sqlxml3/htm/dotnet_0jck.asp">
Поддержка SQLXML .NET</a>.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p>
<a name="71"></a><b>Сетевые службы SQLXML</b></p>
<p>
Поддержка сетевых служб в SQLXML представляет SQL Server в виде сетевой службы, 
которая предлагает функциональность SQL Server клиентам. Вы можете отправлять
запросы SOAP HTTP на сервер, на котором работает SQLXML, для выполнения хранимых
процедур, пользовательских функций (UDFs) и шаблонов.</p>
<p>
Сетевые службы также устанавливаются с помощью IIS Virtual Directory Management
в утилите SQL Server. Когда Web Services Virtual Directory установлена, Вы можете 
добавлять хранимые процедуры и шаблоны на Ваш сайт. Клиенты могут после этого
получать доступ к этим службам по HTTP через протокол SOAP.</p>
<p>
SQL Server 2005 теперь включает встроенную поддержку сетевых служб на сервере.
Однако только SQLXML поддерживает доступ к шаблонам XML через сетевые службы.
Кроме того, SQLXML может быть установлен не на сервере, на котором стоит база данных,
создавая отдельный от базы данных средний уровень.</p>
<p>
Для дополнительной информации о сетевых службах SQLXML
смотрите <a href="http://msdn.microsoft.com/SQL/sqlreldata/XML/default.aspx?pull=/library/en-us/sqlxml3/htm/soapsupport_4u5o.asp">
Поддержка сетевых служб (SOAP) в SQLXML</a>.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+1">
<a name="72"></a><b>XQuery в .NET Framework 2.0</b></font></p>
<p>
Чтобы дополнить появление XQuery в SQL Server 2005, процессор XQuery среднего уровня
встроен в пространство имен System.Xml.Query в релизе .NET Framework V2.0
в Visual Studio 2005 Beta. В этой главе мы покажем, как это дает возможность
выполнять запросы и объединять различающиеся источники данных, такие, как файлы и
реляционные данные, хранимые в  азах данных SQL Server.</p>
<p>
Ниже дан самый простой пример кода запроса, использующегося для выборки
всех книг в книжном магазине, которые имеют свойство литературного стиля -
автобиография и вывода названий книг в виде нового магазина.
Загружаемый локальный файл называется "books.xml", а результаты
выполнения запроса сохраняются в другой локальный файл с названием "output.xml".</p>
<pre><tt>
using (XmlWriter writer = XmlWriter.Create("output.xml"))
{
XQueryCommand xq = new XQueryCommand();
   string query =
         "&lt;bookstore&gt;" +
         "{ for $s in /bookstore/book " +
         "where $s/@genre='autobiography' " +
         "return $s/title }" +
         "&lt;/bookstore&gt;";
   xq.Compile(query);
   xq.Execute("books.xml", new XmlUrlResolver(), writer);
}
</tt></pre>
<p>
Ниже показан запрос:</p>
<pre><tt>
&lt;bookstore&gt;
{for $s in /bookstore/book
where $s/@genre='autobiography'
return $s/title}
&lt;/bookstore&gt;
</tt></pre>
<p>
Класс XQueryCommand - это процессор XQuery. Запрос сначала компилируется
методом Compile, которые выполняет проверку типа значений и генерирует исполнимый код.
Метод Execute выполняет запрос, используя в качестве входных данных документ books.xml.</p>
<p>
Класс XQueryCommand также может выполнять запросы по данным в реляционных таблицах 
в SQL Server с возможностью встроенных команд T-SQL в выражении XQuery. В результате
это позволяет интегрировать два различных языка запросов, работающих в разных доменах,
и дополняет SQL Server 2005, где команда XQuery встроена в команду T-SQL.
В показанном ниже коде запрос используется для выборки всех клиентов из
тестовой базы данных Northwind.</p>
<pre><tt>
declare namespace sql='http://schemas.microsoft.com/framework/2003/xml/sql';
&lt;Customers&gt;{
$for $customer in sql:query("select * from customers", "conn")/*
return customer
}&lt;/Customers&gt;
</tt></pre>
<p>
Метод sql:query позволяет Вам выполнить запрос T-SQL, результаты которого 
возвращаются в виде документа XML в том же виде, что и у функции XQuery doc().
Если результат состоит из реляционных типов, то он конвертируется в XML на клиенте
в виде эффективного потока. Если результаты запроса SQL уже являются данными XML,
например, в случае запроса FOR XML или запроса данных XML, то используется
результат запроса. Если результат не возвращается, как в случае большинства
команд T-SQL DML, то этот результат обрабатывается как пустой документ, 
т.е. это не воспринимается как ошибка. Ниже показан результат этого XQuery,
который выводит всех клиентов из таблицы клиентов, обрамленных в элемент Customers.
Элемент строки автоматически создается для каждой строки таблицы.</p>
<pre><tt>
&lt;Customers&gt;
  &lt;row&gt;
    &lt;CustomerID&gt;ALFKI&lt;/CustomerID&gt;
    &lt;CompanyName&gt;Alfreds Futterkiste&lt;/CompanyName&gt;
    &lt;ContactName&gt;Maria Anders&lt;/ContactName&gt;
    &lt;ContactTitle&gt;Sales Representative&lt;/ContactTitle&gt;
    &lt;Address&gt;Obere Str. 57&lt;/Address&gt;
    &lt;City&gt;Berlin&lt;/City&gt;
    &lt;PostalCode&gt;12209&lt;/PostalCode&gt;
    &lt;Country&gt;Germany&lt;/Country&gt;
    &lt;Phone&gt;030-0074321&lt;/Phone&gt;
    &lt;Fax&gt;030-0076545&lt;/Fax&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;CustomerID&gt;ANATR&lt;/CustomerID&gt;
    &lt;CompanyName&gt;Ana Trujillo Emparedados y helados&lt;/CompanyName&gt;
    &lt;ContactName&gt;Ana Trujillo&lt;/ContactName&gt;
    &lt;ContactTitle&gt;Owner&lt;/ContactTitle&gt;
    &lt;Address&gt;Avda. de la Constitucion 2222&lt;/Address
    &lt;City&gt;Mexico D.F.&lt;/City
    &lt;PostalCode&gt;05021&lt;/PostalCode&gt;
    &lt;Country&gt;Mexico&lt;/Country&gt;
    &lt;Phone&gt;(5) 555-4729&lt;/Phone&gt;
    &lt;Fax&gt;(5) 555-3745&lt;/Fax&gt;
  &lt;/row&gt;
...
&lt;/Customers&gt;
</tt></pre>
<p>
Чтобы выполнить этот запрос в SQL Server, используется следующий код.</p>
<pre><tt>
static String ConnectionString = "database=Northwind;
   Data Source=localhost;Integrated Security=SSPI";

using (SqlConnection connection = new SqlConnection(ConnectionString))
{
       XmlDataSourceResolver resolver = new XmlDataSourceResolver();
   resolver.Add("conn", connection);
   XQueryCommand xq = new XQueryCommand();
   
StreamReader reader = new StreamReader("query.xml");
   xq.Compile(reader);
   
XmlWriterSettings settings = new XmlWriterSettings();
   settings.Indent = true;
   settings.ConformanceLevel = ConformanceLevel.Auto;
   using (XmlWriter writer =
      XmlWriter.Create("output.xml", settings))
   {
      try
      {
         connection.Open();
         xq.Execute(resolver, writer);
      }
      catch (Exception e)
      {
         Console.Out.WriteLine(e.Message);
         Console.Out.WriteLine(e.InnerException.Message);
      }
   }
}
</tt></pre>
<p>
Этот класс XmlDataSourceResolver играет роль связывания соединения базы данных 
с именем, которое может быть использовано в вызове sql:query. Запрос читается из 
локального файла query.xml, компилируется, и создается XmlWriter для записи результатов. 
Заметьте, что установка ConformanceLevel.Auto используется в XmlWriter, который 
автоматически определяет, что создано - фрагмент или документ, и, благодаря
возможности конструировать элементы в результате, XQuery может генерировать и фрагмент,
и документ. Перед выполнением запроса открывается соединение к базе данных,
выполняется запрос и результаты записываются в файл.</p>
<p>
Команда sql:query очень гибкая и мощная из-за возможности поддерживать именованные
параметры в запросе T-SQL и вызывать хранимые процедуры на сервере. Именованные
параметры в sql:query работают так же, как классы System.Data.SqlClient. Параметр 
передается в запрос T-SQL, обозначаемый как "@" и имя.
Привязка между этим именем и действительным значением далее передается в виде
параметра в запрос. Для каждого именованного параметра соответствующее значение
(определяемое позицией в последовательности) используется для привязки.
Количество имен параметров должно совпадать с количеством привязок языка. 
Лучше всего это представлено в следующем примере:</p>
<pre><tt>
declare namespace sql='http://schemas.microsoft.com/framework/2003/xml/sql';
let $country := "USA"
&lt;Customers&gt;{
for $customer in sql:query("select * from customers where Country = @country",
"conn", {"@country"}, {$country})
return $customer/PostalCode
}&lt;/Customers&gt;
</tt></pre>
<p>
В этом случае параметр country передается в запрос T-SQL, связывая переменную
XQuery $country с параметром @country. Результатом является список всех почтовых
индексов клиентов в США.</p>
<p>
Функция sql:query также может использоваться для вызова хранимой процедуры T-SQL, 
передавая параметры описанным выше путем, если это необходимо. Показанный ниже
пример демонстрирует, как вызвать хранимую
процедуру "Ten Most Expensive Products" из базы данных Northwind, 
которая не имеет входных параметров.</p>
<pre><tt>
declare namespace sql ='http://schemas.microsoft.com/framework/2003/xml/sql';
for $prod in sql:query('Exec "Ten Most Expensive Products"', "conn")
return $prod
</tt></pre>
<p>
<a href="#0"><i>[В начало]</i></a></p>
<p><font color="#330066" size="+2">
<a name="73"></a><b>Заключение</b></font></p>
<p>
В этой статье описываются технологии, связанные с XML в SQL Server 2005. Особенности 
серверной стороны включают встроенное преобразование для хранения XML,
индексирование и обработку запросов. Существующие особенности, такие, как
FOR XML и OpenXML, также были улучшены. Поддержка клиентской стороны содержит
улучшения в ADO.NET для поддержки данных типа XML и улучшения в System.Xml для
поддержки XQuery для выполнения запросов на различных источниках данных XML.
Кроме того, улучшения в технологии конвертации SQLXML теперь встроены в SQL Server 2005.</p>
<p>
Поддержка серверной и клиентской стороны полезна для разных случаев. Тип XML 
обеспечивает простой механизм хранения данных XML через вставку данных XML
в нетипизированный столбец XML. Использование схем XML для определения
типизированного XML помогает ядру базы данных оптимизировать хранение этих данных и
выполнение запросов помимо обеспечения проверки данных.</p>
<p>
Тип XML сохраняют порядок документа и полезны для таких приложений, как
приложения документооборота. Этот тип также может обрабатывать рекурсивные схемы XML.
Реляционная модель данных и сейчас является лучшим выбором для структурированных
данных с известной схемой. Даже [n]varchar(max) подходит для случаев, когда
выполнение запросов и обновление не так важны.</p>
<p>
Технология конвертации SQLXML полезна, когда Вы хотите использовать модель
программирования на основе XML, с реляционными данными, хранящимися в таблицах на сервере.
Конвертация основана на определении схемы XML в виде представления XML.
Конвертация может быть использована для bulk загрузки данных XML в таблицы и
для выполнения запросов по таблицам, используя XPath 1.0. Порядок документа при
этом не сохраняется, поэтому технология конвертации полезна для обработки данных XML,
в противоположность обработке документов XML.</p>
<p>
Основные классы XML в System.Xml в будущем релизе .NET Framework V2.0 Beta 1
позволят Вам читать, записывать, перемещать и изменять XML. С улучшениями в
производительности, типизировании и выполнении запросов поддержка XML в релизе V2.0
продолжает лидировать в инновациях, поддержке стандартов и простоте использования.
Эта поддержка также включает процессор XQuery для управления источниками XML
вне SQL Server.</p>
<p>
Технологии серверной и клиентской стороны дополняют друг друга. Технология конвертации 
может усилить возможности серверной стороны, такие, как поддержка порядка документа и
рекурсивные схемы, и найти больше применения в приложениях. 
С другой стороны, CLR расширяет возможности существующих инструментов XML, 
таких, как трансформация XSLT в данные XML. Обработки XQuery на сервере и на клиенте
сильно связаны между собой, а также со спецификацией XQuery от ноября 2003 года.
Обработки схем XML на серверном и среднем уровнях также сильно связаны.</p>
<p>
Shankar Pal - Program Manager ядра SQL Server, работающий в области технологий
XML на стороне сервера.</p>
<p>
Mark Fussell - ведущий Program Manager в команде WebData в Microsoft, 
которая разрабатывает технологии доступа к данным, включая компоненты в
пространствах имен System.Xml и System.Data в .NET Framework,
Microsoft XML Core Services (MSXML) и Microsoft Data Access Components (MDAC).
Его адрес: <a href="http://weblogs.asp.net/mfussell">http://weblogs.asp.net/mfussell</a>.</p>
<p>
<a href="#0"><i>[В начало]</i></a></p>
</div>

</td></tr></tbody></table>
<table bgcolor="#cccccc" border="0" cellpadding="2" cellspacing="2" width="100%">
<tbody><tr>
<td>
<p>Перевод: <a href="http://www.sql.ru/forum/actualtopics.aspx?bid=55">Виталия Степаненко</a>&nbsp;&nbsp;2005г.</p>
</td></tr></tbody></table>
</td></tr>
<tr bgcolor="#6699CC"><td><table border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr><td height="40" bgcolor="#6699CC" valign="CENTER"><font size="-10">
<!-- begin of Rambler's Top100 code -->
<img src="%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0%20XML%20%D0%B2%20Microsoft%20SQL%20Server%202005_files/top100.gif" alt="" height="1" border="0" width="1">
<!--end of Top100 code-->
<table class="tableborder" border="0" cellpadding="0" cellspacing="0" width="100%"><tbody><tr bgcolor="#6699CC"><td>
<!-- begin of Top100 logo -->
<a href="http://top100.rambler.ru/home?id=236431">
<img src="%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0%20XML%20%D0%B2%20Microsoft%20SQL%20Server%202005_files/banner-88x31-rambler-gray2.gif" alt="Rambler's Top100" height="31" border="0" width="88"></a>
<!-- end of Top100 logo -->

<!--Rating@Mail.ru COUNTER--><a target="_top" href="http://top.mail.ru/jump?from=58574"><img src="%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0%20XML%20%D0%B2%20Microsoft%20SQL%20Server%202005_files/counter.gif" alt="Рейтинг@Mail.ru" height="18" border="0" width="88"></a><!--/COUNTER-->
<!-- Yandex.Metrika counter --><script src="%D0%9F%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B0%20XML%20%D0%B2%20Microsoft%20SQL%20Server%202005_files/watch.js" async="" type="text/javascript"></script><script type="text/javascript">(function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter9237463 = new Ya.Metrika({id:9237463, trackLinks:true, accurateTrackBounce:true}); } catch(e) { } }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f, false); } else { f(); } })(document, window, "yandex_metrika_callbacks");</script><noscript><div><img src="//mc.yandex.ru/watch/9237463" style="position:absolute; left:-9999px;" alt="" /></div></noscript><!-- /Yandex.Metrika counter -->
</td>
<td align="right" bgcolor="#6699CC"><font color="white" face="Tahoma,Arial" size="1">&nbsp;Administrator:&nbsp;<a style="color :white" href="http://www.sql.ru/feedback.aspx">Обратная связь</a>&nbsp;<br>Copyright: <font color="white">SQL.Ru  2000-2013&nbsp;</font></font></td></tr></tbody></table>
</font></td></tr></tbody></table></td></tr></tbody></table>



</td></tr></tbody></table></noindex></body></html>